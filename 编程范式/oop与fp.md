## Oop 与 FP

1. 计算机程序本身描述的就是真实世界的抽象流程，设计抽象模型就需要符合现实  
   世界的组织规律与相互联系。
   命令试或者Oop关心解决问题的步骤，函数式编程关心数据的映射（类型-代数结构
   之间的关系）。


- OOP  
  OOP是一种设计思想，是为了是用来处理大型复杂系统的设计和实现的。OOP的优势  
  一定要到了根本就不可能面面俱到，不得不把系统拆成很多Object时才会体现出来。  
  如果某个流程是对多个独立对象相互协作，可以体现一种网状节点结构。其中包含  
  每个对象消息传递的过程，每个节点对象内部都有各自的隐含状态，并且只能通过  
  消息传递改变每个对象的内部状态，状态不可以被直接修改， 往往适合 OOP 建模。 
  **一些误区**  
  - 封装是普遍存在的概念，函数也可以封装。好的封装设计意味着简洁的外部接口  
  和复杂的被隐藏的内部实现。  

  - 多态不限于 OOP，现实的复杂性往往会要求实现一个不是Animal的子类也能"run"  
  比如汽车可以run，一个程序也可以"run"。只要是run就可以，并不在意其类型表达  
  出的包含关系，is-a就不那么重要了。在动态语言里，鸭子类型就可以实现多态，只  
  要觉得它可以run，就给它写个叫run的函数。接口也可以多态，要实现多态可以不用  
  继承，甚至不用class。  

  - 只有继承专属于 OOP 代码复用的特性。 希望通过类型的 is-a 关系来实现代码  
  的复用。绝大部分 OOP 语言会把 is-a 和代码复用这两件事情合作一件事。但是经  
  常会发现这二者之间并不一定总能对上。有时我们觉得 A is a B，但是 A 并不  
  想要B的任何代码，仅仅想表达 is-a 关系而已；而有时，仅仅是想把 A 的一段代  
  码给B用，但是A和B之间并没有什么语义关系。这个分歧会导致严重的设计问题。  
  比如做类的设计时往往会希望每个类能与现实中的实体或概念对应，但如果从代码  
  复用的角度出发设计类，就可能得到很多现实并不存在，但不得不存在的类。一般  
  这种类都会有奇怪的名字和非常玄幻的意思。  

- FP  
  而数据与处理数据的方法分离，数据的状态变化与处理它的函数没有主体上的联系，  
  仅仅是通过了一个流程由确定的输入经过确定的一组函数得到的结果，往往适合 FP。  
  术语：不可变，没有副作用。抽取函数和不变状态。  

- 结合  
  同一个问题又可以拆解为不同的层次，不同的层次可以使用各自适合的抽象模型，  
  高层的可以 OOP，具体到某个执行逻辑又可以 FO 或者指令式。  

2. FP 适合并发编程。  
   并发模型（CSP, Map Reduce, Fork & Join, Promise）  
