
<!-- vim-markdown-toc GFM -->

- [Oop 面向对象 与 FP 函数式](#oop-面向对象-与-fp-函数式)
  - [OOP 面向对象编程：](#oop-面向对象编程)
  - [FP 函数式编程：](#fp-函数式编程)
  - [两者结合：](#两者结合)
  - [语言中的特点：](#语言中的特点)

<!-- vim-markdown-toc -->

---


### Oop 面向对象 与 FP 函数式

> 计算机程序本身描述的就是真实世界的抽象流程，设计抽象模型就需要符合现实世界的组
  织规律与相互联系。  
  命令式或者Oop关心解决问题的步骤，函数式编程关心数据的映射（类型-代数结构之间的
  关系）。


#### OOP 面向对象编程：  

> OOP是一种设计思想，是为了是用来处理大型复杂系统的设计和实现的。OOP的优势一定要
  到了根本就不可能面面俱到，不得不把系统拆成很多Object时才会体现出来。  
  如果某个流程是对多个独立对象相互协作，可以体现一种网状节点结构。其中包含每个对
  象消息传递的过程，每个节点对象内部都有各自的隐含状态，并且只能通过消息传递改变
  每个对象的内部状态，状态不可以被直接修改，往往适合 OOP 建模。 

  **一些误区**  
- 封装是普遍存在的概念，函数也可以封装。好的封装设计意味着简洁的外部接口和复杂
  的被隐藏的内部实现。  

- 多态不限于 OOP，现实的复杂性往往会要求实现一个不是Animal的子类也能"run"。  
  比如汽车可以run，一个程序也可以"run"。只要是run就可以，并不在意其类型表达出的
  包含关系，那is-a就不那么重要了。  
  在动态语言里，鸭子类型就可以实现多态，只要觉得它可以run，就给它写个叫run的函
  数。接口也可以多态，要实现多态可以不用继承，甚至不用class。  

- 只有继承专属于 OOP 代码复用的特性。希望通过类型的 is-a 关系来实现代码的复用。  
  - 绝大部分 OOP 语言会把 is-a 和代码复用这两件事情合为一件事。但是经常会发现
    这二者之间并不一定总能对上。有时我们觉得 A is a B，但是 A 并不想要B的任何
    代码，仅仅想表达 is-a 关系而已。  
  - 而有时，仅仅是想把 A 的一段代码给B用，但是A和B之间并没有什么语义关系。这个
    分歧会导致严重的设计问题。比如做类的设计时往往会希望每个类能与现实中的实体
    或概念对应，但如果从代码复用的角度出发设计类，就可能得到很多现实并不存在，
    但不得不存在的类。一般这种类都会有奇怪的名字和非常玄幻的意思。  

> 合理设计interface和abstract class的继承关系，可以充分复用代码。一般来说，公共
  逻辑适合放在abstract class 中，具体逻辑放到各个子类，而接口层次代表抽象程度。
  可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：


#### FP 函数式编程：  

> 当数据与处理数据的方法分离，数据的状态变化与处理它的函数没有主体上的联系，仅仅
  是通过了一个流程由确定的输入经过确定的一组函数得到的结果，往往适合 FP。  

- 什么是函数式编程  
  [函数式编程简要介绍](https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn)

- 特性：
  不可变、没有副作用、抽取函数和不变状态
  迭代器、生成器、惰性求值、列表推导式、
  高阶函数、柯里化、闭包、偏函数
  类型推导、模式匹配、

- FP 适合实现并发。  
  并发模型：传统利用锁基于共享内存，基于通信共享内存(Actor, CSP)
  并行计算模型：Map Reduce, Fork & Join 


#### 两者结合：  

- 同一个问题可以拆解为不同的层次，不同的层次可以使用各自适合的抽象模型，高层的可以
  OOP，具体到某个执行逻辑又可以 FP 或者指令式。  

- 自底向上的开发模式，并不是从不站在大局考虑问题，而是从某个子系统具体实现开始，从
  局部迭代，逐步反思全局设计，刻意保持低偶合，一个模块一个模块的来，再逐步尝试组合。  
  自底向上强调先有实践，再总结理论，理论反过来指导实践，又从实践中迭代修正理论。这和
  人类认识世界的顺序是一样的，先捕猎筑巢，反思自然是怎么回事，又发现可以生火，又思考
  自然到底怎么回事情。  

  它的反面，是指大一统设计，一开始用UML画出整套系统的类结构，然后再开工设计。这种思
  维习惯，如果是参考已有系统做一个类似的设计，问题不大，全新设计的话，他总有一个前提，
  就是“你能完整认识整个大自然”，就像人类一开始就要认识捕猎和筑巢还有取火一样。否则每
  次对世界有了新认识，OOP的自顶向下设计方法都能给你带来巨大的负担。  

  所以有些人才会说：OOP设计习惯会依赖一系列设计灵巧的BaseObject，然而过段时间后再来
  看你的项目，当其中某个基础抽象类出现问题是，往往面临大范围的代码调整。这其实就是他
  们使用自顶向下思维方法，在逐步进入新世界时候，所带来的困惑。

  当然也有人批判这种强调简单性和可拆分性的Unix思维。认为世界不是总能保持简单和可拆分
  的，他们之间是有各种千丝万缕联系的，一味的保持简单性和可拆分性，会让别人很累。
  这里给你个药方，底层系统，基础组建，尽量用 C的方法，很好的设计成模块，随着你编程的
  积累，这些模块象积木一样越来越多，而彼此都无太大关系，甚至不少 .c文件都能独立运行，
  并没有一个一统天下的 common.h 让大家去 include，接口其他语言也方便。  

  然后在你做到具体应用时根据不同的需求，用C++或者其他语言，将他们象胶水一样粘合起来。
  这时候，再把你的 common.h，写到你的 C++或者其他语言里面去。当然，作为胶水的语言不
  一定非要是 C++了，也可以是其他语言。


#### 语言中的特点：

  - java中一切都是对象，所以函数只能依托于类而存在。当需要一个与某个类不相关的函数
    逻辑来实现算法功能时却给单独的一个算法处理逻辑带上了类型，为了处理类型上的匹配，
    只能将这个函数功能抽象成接口，让实际类型实现这个功能接口。  
    java8 中有了函数式编程的支持就可以在处理算法逻辑时让代码变得更简洁了。  
    lambda表达式的实质是对接口的实现，即某一个具体的函数。

  - python和c++中同样如此。

