
<!-- vim-markdown-toc GFM -->

- [Linux 系统 IO 模型](#linux-系统-io-模型)
  - [参考资料](#参考资料)
  - [五种IO模型](#五种io模型)
  - [selcet，poll，epoll](#selcetpollepoll)

<!-- vim-markdown-toc -->

---


### Linux 系统 IO 模型

#### 参考资料
- [Socket IO 详解](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md)

- [IO多路复用select，poll，epoll比较-1](https://www.cnblogs.com/aspirant/p/9166944.html)

- [IO多路复用select，poll，epoll比较-2](https://www.jianshu.com/p/397449cadc9a)


#### 五种IO模型

- 阻塞IO： IO请求系统调用直到数据被拷贝到用户空间才返回，过程中当前进程被阻塞傻等。

- 非阻塞IO： IO请求立即返回错误，之后**忙**轮询进行系统调用检查IO数据是否就绪(不返回错误)，占用CPU时间片，还会有空轮询情况，CPU利用率不高。

- I/O多路复用： IO请求立即返回，同一个进程可监听多个IO事件(多路广播)，返回优先就绪者。

- 信号IO： IO请求立即返回，IO数据就绪后内核通知用户进程可以进行下一步操作，用户进程系统调用复制数据到用户空间。

- 异步IO： 用户IO请求立即返回，内核自动把IO数据拷贝到用户空间，完成后给用户进程一个反馈信号。

> 只有异步IO是真正的异步操作，其他四个都需要在数据准备好后由用户进程进行系统调用，将数据从内核
  空间拷贝到用户空间。


#### selcet，poll，epoll
> I/O多路复用（multiplexing）的本质是通过一种机制(系统内核缓冲I/O数据)，让单个进程可以监视多个文件描述符，
  一旦某个描述符就绪(一般是读就绪或写就绪)，能够通知相应进行相应的读写操作。

- 功能
  - poll只解决了select文件描述符最大数量的限制，并没有解决性能问题。epoll也没有描述符数量限制。

- 性能
  - select 和 poll 在对监听事件判断是否就绪时，都需进行阻塞调用，调用会把存储文件描述符的数组从用户态拷贝
    到内核态。之后会对该数组进行无差别轮询，如果数组很大时，开销很大，时间复杂度O(n)。

  - epoll 使用一个描述符管理多个用户描述符。epoll底层实现采用回调机制，对每个IO事件注册一个对应的回调处理函数
    (哈希表实现)。通过回调函数将IO就绪的描述符加入就绪队列(链表)，时间复杂度O(1)。  
    被监听的描述符在用户空间和内核空间的拷贝只需一次。  
    之后在获取事件时，内核不需要遍历所有被监听的描述符，只会遍历被加入就绪队列的描述符集合。

- 可移植性：几乎所有系统都支持select，比较新的系统支持poll。epoll仅支持linux系统。

- epoll 工作模式
  - 水平触发LT
    - 调用epoll_wait()检测某IO事件就绪并通知应用程序时，应用程序可不立即处理该事件。下次调用再通知此事件。

    - 支持阻塞和非阻塞。

  - 边缘触发ET
    - 必须立即处理，如不处理，下次调用不会再通知。  

    - 减少了epoll事件的触发次数，效率比LT模式高。

    - 只支持非阻塞。

  
- 应用场景
  - epoll   网络高并发(1000以上)，长连接。若非该场景，用多线程+阻塞I/O可能更好。
    - 为什么高并发，从底层原理及数据结构回答。

    - 为什么长连接，因为epoll描述符存储在内核中，不利于调试，且每次对描述符状态改变都要进行系统调用，频繁系统调用会降低效率。

  - poll    只要平台支持且对实时性要求不高，都应使用poll。

  - select  可移植性好。timeout精度为1ns，poll和epoll为1ms，因此select适用于高实时场景。


内核缓冲区只有4KB。

