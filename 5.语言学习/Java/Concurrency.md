
<!-- vim-markdown-toc GFM -->

- [Java并发知识点 － 主要参考别的资料，这不维护](#java并发知识点--主要参考别的资料这不维护)
  - [线程](#线程)
    - [线程的状态：](#线程的状态)
    - [如何创建线程：](#如何创建线程)
    - [传统并发编程的难点：](#传统并发编程的难点)
    - [如何处理线程之间的数据竞争：](#如何处理线程之间的数据竞争)
    - [如何处理线程之间的竞态条件－通信－信息同步](#如何处理线程之间的竞态条件通信信息同步)
  - [几个重要的关键字](#几个重要的关键字)
  - [JUC包提供了比synchronized-wait语句快更高级别的API来实现多线程同步和协调。](#juc包提供了比synchronized-wait语句快更高级别的api来实现多线程同步和协调)

<!-- vim-markdown-toc -->



## Java并发知识点 － 主要参考别的资料，这不维护

### 线程

#### 线程的状态：
- New(新创建)： 这时线程**还没有运行**代码，有一些基础工作要做。

- Runnable(可运行)：  
  一旦调用start()方法，线程才处于runnable状态。注意此时为**可运行**而不是**正在运行**。  
  当线程数目多于CPU数目时，抢占式调度系统采用时间片机制来保证每个线程都能被执行。

- Blocked(被阻塞)： 

- Waiting(等待)：

- Timed waiting(计时等待)：

- Terminated(被终止)：


#### 如何创建线程：


#### 传统并发编程的难点：


#### 如何处理线程之间的数据竞争：


#### 如何处理线程之间的竞态条件－通信－信息同步
因为存在竞态条件，所以需要线程之间进行通信确保执行的先后顺序，本质是消息的同步，消除信息差。


### 几个重要的关键字
- **volatile：**  解决了多个线程间数据**读取**可见性的问题。  
  - 被标记为volatile的字段会禁止编译器指令重排。
  - 在读取字段时强制CPU刷新本地内存缓冲使之与主内存状态同步。
  注：该关键字在C++中含义与Java中不一样，C++中没有线程同步的功能，即使有也只是部分编译器的扩展，无可移植性。  
      volatile 标记的变量不能提供原子性，如取反，写入，但是修饰Long或Double类型变量，可以使得操作具有原子性。

- **synchronized：**  解决了多线程之间数据竞争的问题，没有解决多线程协调(执行顺序)的问题。  

- **wait 和 notify：**  
  这两个方法解决线程间协调(执行顺序)的问题。当条件不满足时，线程进入等待状态。

  - wait方法**只能**在synchronized语句块中调用。

  - 假设this指向一个用来封装线程间共享数据结构的类实例。调用wait方法后将**释放this的锁**，并使调
    用synchronized-wait语句块的线程进入**等待状态**。

  - 当某个条件满足，其他线程调用this.notify方法**唤醒等待的线程**，等待的线程将**重新获得this的锁**。  

    <img src="../9.Resources/Java-multithread-wait-notify.jpg">


### JUC包提供了比synchronized-wait语句快更高级别的API来实现多线程同步和协调。

- **ReentrantLock 和 Condition：**  
  配合可以替代synchronized与wait-notify的功能，Condition对象必须从ReentrantLock对象获取。

- **ReadWriteLock：**   
  只允许一个线程写入，允许多个线程同时读取。 适合读多写少的场景。同一个实例，有大量线程读取，仅有少数线程修改。  
  例如一个论坛帖子，回复不频繁，可看作写入。浏览频繁，可看作读取。

- **Concurrent 集合：**   
  线程安全的集合类。
  <img src="../9.Resources/Java-threadsafe-BlockConllection.png">


