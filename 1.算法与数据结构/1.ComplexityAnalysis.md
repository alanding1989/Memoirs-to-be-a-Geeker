
<!-- vim-markdown-toc GFM -->

- [分析任何数据结构算法的思考方向](#分析任何数据结构算法的思考方向)
- [常用的指标](#常用的指标)
  - [为什么要引入这4个概念？](#为什么要引入这4个概念)
- [复杂度分析](#复杂度分析)

<!-- vim-markdown-toc -->


- **[算法复杂度速查表](https://linux.cn/article-7480-1.html)**


### 分析任何数据结构算法的思考方向

0. 基本的结构特点，属于线性表、图、树，更详细的分类。

1. 具体类型下再考虑遍历访问、修改、插入、删除**不同位置**元素的效率，时间复杂度。  
   不同位置实际就是考虑最好，最坏，以及出现在**不同位置概率不同**等情况时复杂度的区别。

2. 不同的输入**数据规模**造成的效率差异。

3. 空间复杂度，静态(未修改)及动态(修改后)情况内存占用的大小及原因。

4. 是否线程安全。

5. 可能的使用场景，具体问题对执行时间和空间的要求，空间换时间或者时间换空间。

6. 底层的数据结构与增删改查的算法实现，若是支持指针的语言还要考虑传值、引用、指针的
   效率，内存占用影响。


### 常用的指标
- 最好情况复杂度

- 最坏情况复杂度

- 加权平均情况复杂度： 用代码在所有情况下执行的次数加权平均值表示。

- 均摊时间复杂度  
  - 代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度。

  - 低级别和高级别复杂度出现具有连贯的时序规律，因为极少数情况复杂度才较高，因此大多数情况下均摊结果一般都等于低级别复杂度。


#### 为什么要引入这4个概念？
- 同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度。

- 代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。


### 复杂度分析

  <img src="../7.Resources/time-complexity.jpg">

- 对数 O(logn)
  - 一些分治算法，通常都是无限循环的

  - 如果一段代码复杂度是O(logn)，循环执行n次，复杂度为O(nlogn)。例如，归并排序，快速排序

  - 所有对数阶时间复杂度都可记为O(logn)，因为对数间可以互换，$log_3n = log_32 * log_2n$

- O(m+n), O(m\*n)
  ``` C
  int cal(int m, int n) {
    int sum_1 = 0;
    int i = 1;
    for (; i < m; ++i) {
      sum_1 = sum_1 + i;
    }

    int sum_2 = 0;
    int j = 1;
    for (; j < n; ++j) {
      sum_2 = sum_2 + j;
    }

    return sum_1 + sum_2;
  }
  ```

