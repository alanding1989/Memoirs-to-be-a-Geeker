
<!-- vim-markdown-toc GFM -->

- [数据结构](#数据结构)
- [一、不同角度的结构分类](#一不同角度的结构分类)
    - [逻辑结构](#逻辑结构)
    - [物理存储结构](#物理存储结构)
- [二、基本数据结构](#二基本数据结构)
  - [１. 线性表 - 只有前后关系，即一对一](#-线性表---只有前后关系即一对一)
    - [数组](#数组)
    - [链表](#链表)
    - [栈](#栈)
    - [队列](#队列)
    - [递归](#递归)
    - [跳表 - 链表实现二分查找](#跳表---链表实现二分查找)
    - [哈希表](#哈希表)

<!-- vim-markdown-toc -->

---


## 数据结构

> 编写一个好的程序之前，必须分析待处理问题中各个对象的特性，以及对象之间的关系。


## 一、不同角度的结构分类

#### 逻辑结构
| 集合结构 | 线性结构 | 树形结构 | 图形结构 |
|----------|----------|----------|----------|
| 从属关系 | 一对一   | 一对多   | 多对多   |


#### 物理存储结构
逻辑结构在计算机内存中的存储形式。
- 顺序存储：存储在**连续的**存储单元里。

- 链式存储：存储在**任意的-不一定连续**存储单元，通过地址指针找到下一个数据元素。


## 二、基本数据结构

### １. 线性表 - 只有前后关系，即一对一

#### 数组 
> 为什么索引下标从0开始
- 特点：连续顺序存储，数据类型相同，快速随机访问，基址+偏移。

- 缺点：因为存储连续，所以插入、删除要移动元素，效率低。数据类型相同。

- 优化
  - 插入：如果数组元素没有顺序要求，可以先将要插入位置上的元素复制到数组最后，替换该位置上的元素，就免去了移动元素。

  - 删除：删除多个元素时，先记录要删除的元素位置，最后一次性删除，免去删一个就要移动元素的消耗。  
    Jvm标记清楚垃圾回收算法。

- 实现
  - 动态扩容


#### 链表
- 特点：非连续存储，数据类型相同，下标查找只能顺序访问。

- 缺点：随机访问元素不高效

- 优化：用散列表记录结点值的对应内存地址

- 单链表
  - 插入、删除给定指针指向的结点时，无法获知前驱结点，还需从头遍历以找到前驱结点

  - 删除结点中值等于某个给定值的结点时，三种链表复杂度都为O(n)

- 循环链表

- 双向链表 
  - 双向遍历，占用更多内存，用空间换时间
  - 插入、删除给定指针指向的结点时，可以获知前驱结点
  - 有序链表中，按结点值查询效率更快，因为可记录上次查找的位置，平均只需要查找一半的数据。

- 双向循环链表

- 实现注意点
  - 理解指针及引用
  - 注意内存泄漏
  - 利用无数据的带头结点(哨兵结点)简化实现
  - 注意边界条件的正确性


#### 栈
- 特点：后进先出，只在一端插入和删除数据，连续存储。

- 实现
  - 栈顶指针
  - 数组 - 顺序栈
  - 链表 - 链式栈


#### 队列
- 特点：先进先出，连续存储

- 缺点：单端队列假溢出

- 优化
  - 不用每次出队移动元素，当没有空间时一次性移动
  - 循环队列 

- 实现
  - 顺序队列
  - 链式队列 - 可实现支持无限排队的**无界队列**
  - 队头指针
  - 队尾指针
  - 确定好队空和队满的判定条件
    - 非循环队列
      - 队满 tail == n
      - 队空 head == tail
    - 循环队列
      - 队满 (tail + 1) % n == head
      - 队空 head == tail
      - 循环队列会浪费一个数组的存储空间

- 业务应用
  > 适用于大部分资源有限，需要实现请求排队的场景。

  - 阻塞队列：实现“**生产者－消费者**”模型
    - 在队列为空的时候，从队头取数据会被阻塞，直到队列中有了数据才能返回。

    - 如果队列已满，插入数据的操作会被阻塞，直到队列有空闲位置再插入，然后返回。

    - 可以配置不同个数，或者控制队列长度，协调生产和消费的速度，达到**限流**。

  - 并发队列：利用CAS原子操作减小同步锁的粒度，甚至无锁，增加并发度。
  
  - 消息队列：分布式应用，kafka

  - **无界队列问题**
    - 在线程池请求排队的场景中会导致过多请求排队等待，请求处理相应时间过长。实时性系统用基于链表的无界
      队列不合适，这时有界队列就需要设计合理的队列大小，太大导致等待请求太多，太小导致无法充分利用系统
      资源。  

    - Java中线程池使用无界队列，当核心线程数满后，任务优先进入等待队列。如果等待队列也满了后，才会去创
      建新的非核心线程。也就是说设置最大核心线程数对使用无界队列的线程池执行没有影响，一是不会达到设置
      的最大线程数，二是就算初始默认就为最大线程数也一样能继续运行。若创建和处理速度差异较大，无界队列
      会保持快速增长，内存飙升，直到耗尽系统内存。
    
    - Java中线程池使用有界队列，当核心线程，非核心线程，任务队列全部满负荷工作时，下一个进来的任务会被
      直接拒绝，抛出RejectedExecutionException异常。


#### 递归
- 递归条件，什么时候可以用递归。
  - 问题的解可以分解为几个子问题的解。

  - 本问题与分解后的子问题，除了数据规模不同，求解思路完全一样。

  - 存在递归终止条件，边界情况。

- 实现
  - 写出递推公式，找到终止条件。

  - 防止栈溢出，尾递归优化，限制递归深度，自己实现一个堆上的栈。

  - 防止重复计算，使用缓存，比如哈希表。


#### 跳表 - 链表实现二分查找
- 查询时间复杂度为O($logn$)，给链表建立多级索引，用空间换时间。

- 动态数据结构，插入和删除时间复杂度O($logn$)，只要查询到要插入的位置，修改指针很快。

- 空间复杂度O(n)，不过与实际开发中存储的对象相比，索引的额外空间就可以忽略了。

- 跳表的索引在插入一定量数据后，需要进行动态更新，否则当两个索引结点之间数据非常多时，效率下降，
  极端情况会退化成单链表。


#### 哈希表
- 特点：通过散列函数把元素键值映射为数组下标，将数据存储在数组中对应下标的位置。

- 缺点：随机访问元素不高效

- 优化：用散列表记录结点值的对应内存地址

- 哈希函数
  - 哈希函数计算得到的哈希值是一个非负整数，数组下标从0开始。
  - 如果key1  = key2，那hash(key1) == hash(key2)
  - 如果key1 != key2，那hash(key1) != hash(key2)，哈希冲突几乎无法避免

- 哈希冲突
  - 

