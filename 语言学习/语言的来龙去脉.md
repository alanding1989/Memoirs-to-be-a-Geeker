

#### 语言之间的联系与发展


- **语言只是工具，语言之间重要的区别是语言的特性，或者解决某一领域问题的关键技术，
而不是乱七八糟的语法和printf %d %s 的规则。**


> 以下文章摘录自知乎。  
  结合了底层一些知识，编译原理，把多个语言对硬件的抽象串起来讲，非常不错的文章。  

---


<span class="RichText ztext CopyrightRichText-richText" itemprop="text">相信每一个计算机科班出身的同学或许都有这样的经历：在大三的某一天，仿佛打通了全身筋脉一般把三年的所学：“数电里的与非门——计算机体系结构——汇编语言——C 语言——C ＋＋语言——Java 语言”所有知识全部串联了起来。所有这些语言的出现都仿佛都有了必然性和追根溯源的历史感。<br><br><br><p>**阅读指引**</p><p>读懂此文，需要以下基础:</p><p>1. 至少写过 50000 行的代码;</p><p>2. 汇编基础（静态数据段，代码段，堆栈段）。</p><br><br><p>有以下或者类似知识就更好了：</p><p>1. C 语言编译，C++对象模型，MFC 反射的实现</p><p>2. JAVA 的解释器运行原理</p><p>3. 使用过 javascript，Python，PHP：感受过代码和类型系统在运行时的自由程度的不同</p><p>4. 计算机组成原理</p><br><br><p>**序 —— 一些问题**</p><p>1. 程序设计语言的目的是什么？</p><p>2. 为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统、一个自动打车 APP）</p><p>3. 为什么类型申明在 C 语言中要与控制流隔离开来?</p><p>4. 现在主流语言最基本的元素是？</p><p>5. 有没有语言它的类型结构，在运行时也可以改变？</p><p>动态性？</p><br><p>什么是动态性？</p><p>1. 编译后确定了什么信息，之后不再改变；</p><p>2. 运行时可以改变、添加什么；</p><p>3. 运行时是否保存着类型信息。</p><br><p>程序中的信息分为几类？</p><p>1. 数据信息</p><p>a) 编译时 Meta-Data 元数据（类型框架、空间占用）</p><p>b) 运行时 Meta-Data 元数据（继承体系、用于 new 或者反射）（特别区别编译与运行的 Meta-Data 的不同。）</p><p>c) 堆栈段中地址偏移（C++的 switch case 中不能声明变量、共享内存）</p><p>d) 静态段中地址</p><p>2. 指令信息</p><p>a) 代码段（动态性需要操作系统或者虚拟机支持，例如动态链接库，动态类加载，lisp 语言自生成代码）</p><br><br><p>**语言举例**</p><br><p>**汇编语言**</p><br><p>汇编语言没有动态性吗？</p><p>没有。首先，寄存器、数据段、堆栈、代码段完全由程序员控制。完完全全是写死了的。然后，根据冯诺伊曼机的规则；取指令，执行，取指令，执行……</p><br><br><p>既然都有数据段了，还要堆栈段来做什么？这不是多余？</p><p>一开始本没有堆栈，直到 60 年代出现了 module 模块化，才有了堆栈。汇编中的模块叫子程序，不过仍旧靠程序员全权控制。</p><br><p>堆栈和模块化的优点有？</p><p>1. 递归</p><p>2. 功能分离到模块，可复用</p><p>3. 封装作用域</p><br><p>堆栈和模块化的缺点有？</p><p>1. 时间上：保存现场、还原现场的代价（另，高级语言编译“消除尾递归”节约部分成本）</p><p>2. 空间上：爆栈的危险</p><br><br><p>**C 语言**</p><br><p>C 语言比起汇编多了什么东西？</p><p>1. 编译器</p><p>2. 表达式（相比汇编，可以处理多个操作数了。）</p><p>3. 函数与模块｛｝（真·模块化，栈操作无需程序员完成）</p><p>4. 类型（原子类型、结构类型、数组、指针）</p><p>5. 头文件，库</p><p>总之，C 语言并没有比汇编多了新的特性，它只是把汇编的繁琐操作抽象出来，让编译器完成，减轻程序员负担。</p><br><p>编译器的作用是？</p><p>（减少程序员负担）</p><p>1. 解析表达式，控制流（汇编中指令只有 1-3 个操作数，而表达式可以多个操作数）</p><p>2. 模块和函数的抽象（完成堆栈中保存恢复现场的工作）</p><p>3. 类型变量的管理（所有变量被替换成直接访问的地址，最快的访问速率）</p><p>4. 代码优化</p><br><p>变量是替换成可以直接访问地址的？</p><p>a) 编译时的 Meta-Data（struct 的成员，数组的长度，以便替换到指令流；只在编译器中维护，编译结束后丢弃）</p><p>b) 计算出每个变量相对于该模块的偏移（一旦算出该偏移地址，将固定在执行码中，无法改变；就是说编译完成后，所有变量的偏移地址都固定下来了。）</p><p>c) 对变量的存储进行管理（所有的变量/内存地址的布置，都是在编译时确定的；也就是说，可执行码中没有类型信息，只有地址，任何数据都是地址来操作，完全和汇编类似。至于寄存器的安排，那是更下一层的类似缓存策略算法的结果。）</p><br><p>编译出来的执行码与汇编的执行码有特征的区别吗？</p><p>没有。特别是在编译器优化之后。</p><p>无法通过执行码，区分汇编和 C 程序。</p><p>打个比方，一只“程序猫”在黑笼子里，在里面喵喵的叫，无法通过它的叫声来判断它是“汇编猫”还是“C 语言猫”。</p><br><p>从效率上来讲，C 的多余代价在哪里？</p><p>1. 编译的时间</p><p>2. 模块的堆栈操作</p><p>总之，经过优化的 C 程序执行码与汇编效率几乎相同。</p><p>因为从理论上来说，C 并没有引入运行时的新机制。</p><p>我理解的 C 语言只是一种汇编的宏而已。</p><p>**C++语言**</p><p>（推荐《深度探索 C++对象模型》）</p><br><p>C++语言比 C 语言多了什么？</p><p>1. 成员函数</p><p>2. 类型继承体系</p><p>3. 虚函数、虚继承</p><p>4. 模板</p><p>5. 涉及到了多种编程范式</p><p>（开始更抽象，语言逐渐开始脱离冯氏结构。）</p><p>其中，面向对象的思想，让程序与现实事物的关系更加紧密。</p><p>程序设计的负担，也因为 OO 与设计模式的流行，而变得轻松。</p><br><p>编程范式是什么？</p><p>就是一套指导思想行为准则。</p><p>（例如，C 是过程式，Haskell 是函数式，JAVA 是面向对象，Python 是简单的大杂烩，shell 是调用命令的，lua 是调用 c 程序的，PHP 是写页面的，ProLog 是线性逻辑推理的。</p><p>再例如，UML 是描述规格 specification 的，XML 是存储数据的。</p><p>再再例如，CSS 是描述网页表现的，HTML 是描述网页内容的。</p><p>javascript 比较神奇，不敢说。）</p><br><br><p>C++有什么编程范式？</p><p>1. 过程式（使用 STL 的类 C 语言编程）</p><p>2. ADT 式（自定义抽象数据类型，继承；但是不用 new，不用 virtual；拷贝构造；为了防止资源泄漏，也发明了 RAII 的方式进行资源的初始化和释放）</p><p>3. 面向对象式（使用 new，使用 virtual，需要指针或引用；实现多态。）</p><p>4. 泛型编程（《Modern C++ Design》各种奇淫技巧，业务层代码比较少遇到）</p><br><p>C++编译器是怎样实现的？</p><p>C++开始有一个叫做 cfront 的编译器，即把 C++语言先翻译成 C 语言。</p><p>然后再用 C 编译器来编译，C 的编译器并不知道此段代码是来自 C++还是 C。</p><br><p>C++语言特性分别是怎样实现？简单说。</p><p>1. 成员变量：和 C 语言的 struct 类似，最后也会被直接替换成地址，便于高效访问。</p><p>2. 成员函数：使用特殊函数名编码方案，翻译成 C 函数，并添加 this 指针作参数。（如**\_clsA12345func001(...,clsA \*this)）</p><p>3. 类型继承体系：通过 C++编译时的 Meta-Data 来实现。即在编译时，编译器是知道类型信息与继承体系的，但是编译成 C 语言后就丧失了此类型信息。</p><p>4. 虚函数、虚继承：为了支持多态，这也是“面向对象”最重要的特性，使用了虚函数表和虚基类表。注意，运行时多态是通过运行时查表实现的。稍后详细说。</p><p>5. 模板：通过代码复制的方式实现。每次编译都需要重新编译，不能编成库文件直接使用。</p><br><p>C++编译器的准则与 virtual 机制？</p><p>1. 首先，C++的编译准则，希望做到与 C 一样的效率。希望做到以下：</p><p>——a) 没有运行时调用间接性。任何数据在运行时都是一个地址直接就访问到。</p><p>——b) 没有运行时的 Meta-Data。无需通过 Meta-Data 来访问某个复杂的类层次。</p><p>——c) 所有的数据都希望用 C 中 struct 来实现，即在编译时就确定好对象及其成员地址。</p><p>2. 以上，在过程式范式，与 ADT 范式中都是成立的。</p><p>3. 但是，在面向对象范式中，渴望做到：</p><p>**需要维系着同一个继承体系成员结构的一致性，只有这样，才能保证运行时的多态性。即希望通过同一个入口，访问到父类或者子类的相同数据成员、函数成员，而不在乎具体对象的是父类还是子类。**</p><br><p>C++的 virtual 机制如何实现的？</p><p>a) 虚函数</p><p>i. 虚函数，运行时，每个有虚函数的类型（哪怕是子类）都维持着一个虚函数表，这已经是运行时的 Meta-Data，通过查表，即可找到对象自己的虚函数。</p><p>ii. 例如下图中 clone 肯定是 object.**vptr\_\_Base-&gt;#3()，无论具体的对象。</p><p>b) 多重继承</p><p>——如何处理后继的 base 基类？由编译器判断指针类型并加上相应的偏移。</p><p>c) 虚继承</p><p>——添加一个虚基类指针，指向共享部分。</p><p>这样的缺点有两个：</p><p>1. 虚基类的子类都要背负一个基类指针指向共享部分。如果继承了多个虚基类，还需要多个这样的指针。（Microsoft 的解决方法是增加一个虚基类表，类似于虚函数表。）</p><p>2. 虚继承链条的增加，会导致间接访问的层次增加。例如两个菱形继承的串联。</p><br><p>跨平台的级别有哪些级别？——头文件，库，源代码</p><p>1. C++确实在源代码的层次是可能跨平台的（例如《POSA2》中加了针对不同平台的各种宏的代码）。</p><p>2. 也可以通过相同的头文件去访问不同平台的库。</p><p>3. 但是，不同操作系统中的不同的 API 大大增加了跨平台的难度。</p><p>4. 跨平台的责任留给了程序员（充斥着大量宏的 C++跨平台代码确实让人头疼。）</p><p>5. 编译器面对不同的系统也不敢作为，它只是负责编译源代码，链接。</p><br><p>如何使用 C++才能保证其高效性能？</p><p>1. 有额外负担的机制：虚函数，虚继承，拷贝构造。</p><p>2. 用一次虚函数，多了一次指针寻址的效率损失，并且相对于 inline 内联（另，inline 是编译器优化的重头），还损失了保存和恢复现场的效率。</p><p>3. 用一次虚继承，也多一次指针寻址的效率损失。（另，虚基类没有成员变量没有虚函数的时候会被优化。这也是 JAVA 可以多重继承接口 interface 的原因。）</p><p>4. 不要使用 virtual 在复杂的多继承，深层次继承中。</p><p>5. 编译速度会较慢：virtual 机制会使编译器处理更多的 Meta-Data。</p><br><br><p>**JAVA 语言**</p><p>（推荐《本地 Java 代码的静态编译和动态编译问题》）</p><br><p>JAVA 语言比 C++语言多了什么？</p><br><p>1. 虚拟机</p><p>a) 跨平台</p><p>b) 动态编译</p><p>c) 动态特性</p><p>2. 没有指针</p><p>3. 没有类的多继承，有接口的多继承。</p><p>4. 统一的库</p><p>从编译来说，JAVA 比 C++迈出了一大步。</p><p>它的跨平台特性和运行时的灵活性，为 JAVA 自己以及未来语言都提供了很多可能性。</p><br><p>虚拟机的好处有什么？</p><p>1. 跨平台：在 OS 与字节码间隔了一层。实现了程序员无负担的跨平台。</p><p>2. 动态编译：许多信息不必在编译后确定，为动态特性提供可能，稍后详细说。</p><p>3. 运行时维护着类型信息，甚至可以加载新的类型。（CORBRA 依赖这个实现）</p><br><br><p>JAVA 编译执行的过程是怎样的？</p><br><p>1. 编译后产生一个基于堆栈的字节码。</p><p>2. JRE 在不同的 OS 上提供支持。</p><p>3. 起初的 JRE 是解释执行的，效率低下。</p><p>a) 获取待执行的下一个字节码。</p><p>b) 解码。</p><p>c) 从操作数堆栈获取所需的操作数。</p><p>d) 按照 JVM 规范执行操作。</p><p>e) 将结果写回堆栈。</p><br><p>JAVA 是如何解决执行效率低下的问题呢？</p><p>使用 JIT（Just-in-time）编译器进行动态编译。</p><br><p>JIT（Just-in-time）是怎样运行的呢？如何解决了效率的问题？ </p><p>如上图：</p><p>1. 每次按照一个 function 来编译。转成中间表示，并优化其效率，再生成可执行码。</p><p>2. 编译器的编译线程和执行线程是分开的，应用程序不会等待编译的执行。</p><p>3. 分析框架 Profiler 会观察程序行为，对频繁执行的 function 进一步优化。（例如 function 内部对象维持一个池不必每次生成。）</p><br><p>动态编译的优点有什么？</p><p>可以根据程序的行为，优化其代码</p><p>1. 例如频繁执行的 function——热方法</p><p>2. 例如 arrayCopy 方法，如果每次都拷贝大段内存，在指令集中有特别指令可以加速。</p><p>3. 例如类层次结构，多态的优化。（大多数虚调用都有其固定的一个目标，JIT 因此生成的直接调用代码比虚表调用代码的效率会更高。）</p><br><p>动态编译的缺点有什么？</p><p>1. 大量的初始编译会影响程序启动时间。</p><p>2. 运行时候的编译，行为分析都需要花费时间。</p><p>3. 运行效率达到稳定需要时间。</p><p>4. 实时 GUI 型的程序不能忍受“动态编译”和“GC”带来的延迟。</p><p>JAVA 如何解决实时的需求？</p><br><p>使用 AOT（Ahead-of-time）编译器：预先编译成为可执行码。</p><p>AOT（Ahead-of-time）的缺点:</p><p>对于一些动态特性的支持效率低下</p><p>1. 反射机制</p><p>2. 运行时类加载</p><p>JIT 与 AOT 的对比</p><br><br><p>总体来说，JAVA 适合怎样的应用呢？</p><p>JAVA 比较时候需要长期运行的应用，例如 Web 服务器，Daemon 服务。</p><br><p>**函数式语言**</p><br><p>函数式语言通常有哪些呢？</p><br><p>1. 函数式语言</p><p>a) Lisp</p><p>b) Scheme</p><p>c) Haskell（纯函数式）</p><p>d) F#？</p><p>2. 包含了函数式特性的语言</p><p>a) Python</p><p>b) Javascript</p><p>c) JAVA</p><p>d) C?</p><br><br><p>函数式语言有哪些特性？</p><br><p>1. 函数无副作用，只对输入输出有作用</p><p>2. 高阶函数，lamda 演算。(这个像 C 函数指针，但是它是高阶的，即返回值可能也是函数)</p><p>3. 没有过程，类似规格说明的语法，更容易理解，自解释。</p><p>4. 基于 list 的编程，函数更通用。</p><p>5. 惰性计算（这个很像“树形 DP”）</p><p>6. 有对应的数学形式化表达，有可能证明其正确性。（最终目标可能是保证程序没有 bug。）</p><p>7. 其模型适合多核或者分布式的计算。</p><p>a) 不变性（immutable）</p><p>b) 惰性计算/按需计算（lazy evaluation）</p><p>c) **最重要的是，由于函数式语言不可在同一数据上做修改，每一次运用一个函数都会在新的位置产生新的数据，这与过程式语言在同一位置对数据做多次操作不同：函数式语言的函数依赖于前一次函数产生的结果数据，过程式语言依赖于数据的位置。这里函数式语言就暗含了计算的依赖顺序，如果没有前后顺序关系，就可以并发。而过程式语言没有指定这个顺序，就需要通过加锁、Actor、Channel 等模式来指定这个顺序**</p><p>总的来说，函数式语言，向着更抽象迈了一大步，更像是数学上的表达，几乎与冯诺伊曼体系断绝了关系。</p><br><br><p>函数式语言的劣势？</p><br><p>1. 效率不高（因为其抽象，远离了冯诺伊曼体系）</p><p>2. 平台以及开发环境都比较简单。</p><p>3. 缺少推广，应用不广泛</p><br><p>**逻辑程序设计**</p><p>ProLog 语言，线性逻辑。人工智能语言。没有接触过。</p><br><br><p>**总结**</p><p>动态性有哪些呢？</p><p>1. 多态性：运行时根据具体对象来访问属于它的方法。（而不理会指针的类型。）</p><p>2. 反射：运行时维系着类型结构的 Meta-Data。</p><p>3. 运行时类加载：运行后再次加载新的数据类型和指令流。</p><p>4. 动态链接：OS 根据按需链接库文件。</p><br><p>编译语言 和 解释语言 的分界在哪里？</p><p>语言本身并没有编译类型或者解释类型。（例如：JAVA 也可以静态编译后成可执行码。）只有少数运行时特性是依赖于解释型的。（可能需要运行环境的支持。）</p><br><p>为什么解释语言都需要虚拟机或者运行环境支持？</p><p>动态编译，运行时 Meta-Data 的保存，这些功能对于每个程序都是一致的。</p><p>所以把它们分离开来，不必每个程序植入这些代码</p><br><p>非脚本语言 和 脚本语言</p><p>脚本语言，我理解是负责调度其他代码的语言。</p><p>例如 shell 脚本（调用命令），lua（调用 C）。</p><br><p>跨平台分为哪些层次？</p><p>1. 源码跨平台（C，C++，但是因为系统调用接口不同，程序员负担太大，但是汇编却不是。）</p><p>2. 执行码跨平台（JAVA，有些语言直接从源码解释执行，例如 Javascript，PHP）</p><p>发展历史（推荐《近看图灵碗 (一. 从苏黎世到巴黎)》）</p><br><p>学术上有哪些实验性语言？</p><p>1. Fortran</p><p>2. ALGOL58</p><p>3. ALGOL60</p><p>4. Lisp</p><p>5. smalltalk</p><br><p>常用语言</p><p>过程式：C，ALGOL，Pascal，</p><p>面向对象式：C++，smalltalk，JAVA，Delphi</p><p>函数式：Lisp，Scheme，Haskell，</p><p>逻辑式：Prolog</p><p>脚本？PHP，Python，Ruby</p><p>存储描述信息：XML，CSS，HTML</p><br><p>**回答问题**</p><p>程序设计语言的目的是什么？</p><p>1. 控制数据</p><p>2. 控制指令流</p><p>为什么大多数语言有控制流？逐行执行+跳转。这与我们的需求差很远（例如一个教务管理系统。）</p><p>逐行执行，很大程度是起源于冯诺依曼体系结构。</p><br><p>为什么类型申明在 C 语言中要与控制流隔离开来?</p><p>因为在编译时，具体的类型信息，要转化成地址偏移，然后替换控制流中的类型变量。</p><br><p>现在主流语言最基本的元素是？</p><p>控制流 与 类型系统。</p><br><p>有没有语言它的类型结构，在运行时也可以改变？</p><p>Javascript 只有对象没有类，使用 prototype 的方式继承，运行时给某个对象添加新的数据成员。没有类型体系。</p><p>许多后来的语言在运行时都保存着类型信息的，例如 Python，JAVA。</p><br><p>**综上所述**</p><p>控制流——指令流</p><p>类型系统——为了计算出变量地址信息</p><p>区分运行时的 Meta-Data 与编译时的 Meta-Data</p></span>
