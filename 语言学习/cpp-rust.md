
<!-- vim-markdown-toc GFM -->

- [Cpp和Rust学习笔记](#cpp和rust学习笔记)
  - [1. 内存管理](#1-内存管理)
  - [2. 引用与借用机制](#2-引用与借用机制)
  - [3. 数组和字符串的切片](#3-数组和字符串的切片)
  - [4. 泛型系统](#4-泛型系统)

<!-- vim-markdown-toc -->


### Cpp和Rust学习笔记

简单记录一些语言的特点及关键问题的处理异同


---

#### 1. 内存管理  
> 所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序
  运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust
  则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检
  查。  

c++和c中可能有多个指针指向同一个堆中动态分配的对象，给内存管理造成很大麻烦。  
即申请内存之后忘记释放造成内存泄漏、多次释放相同内存、访问已经释放了的内存产生的bug。

rust解决了c++和c一直以来内存管理的痛点问题，c++和c中内存管理都是**变量跟着内存地址**
(指针)走，而rust中却是**指针跟着变量走**。  
rust中通过变量进出作用域的约定，让所有未实现 Clone 特质(trait)、需要在堆上动态分配
内存的类型的变量通过指针信息的传递 move，实现了在任何时刻任一堆上的对象都只能有一个
变量引用它的内存地址，即任何时刻指向这个堆上对象的指针引用计数只能为1，离开变量作
用域时，rust将自动销毁这个指针并释放内存。
关键的是，这样的功能不会造成任何运行时开销！

> 上面的这个move的特性实际上是rust中所有权(ownership)机制的体现。

注：rust里面实现了Clone 特质的类型可以进行深拷贝，即复制变量数据而不是复制指针信息。
而java里的Clone接口是浅拷贝。

---

#### 2. 引用与借用机制  

可变引用与不可变引用在语言层面上解决了多线程并发编程的资源竞争问题。  

---

#### 3. 数组和字符串的切片  

- rust中的切片实际是一个结构体，含有一个指向某数组**首元素**地址的指针和该数组
  片段长度的字段。  
  所以切片是一个数组部分元素的**定长**引用。  
- 而go中切片大小是可变的，因此它的结构体多了一个代表切片capacity的字段，其他一样。  
- rust和go通过这样的结构避免了c和c++中直接操作指针运算可能导致的访问越界问题。
- rust中的&str字符串切片其实和c中字符数组概念是一样的，只是rust默认支持UTF-8编码，
  但是一个char类型内存大小是平台无关的，占用32bit，4个byte。但是字符串类型String
  的内存占用是变长的。  

---

#### 4. 泛型系统  
> rust有两种实现泛型的手段，一种动态一种静态。  

静态派发叫做trait，类似于c++模板，在编译时就能生成特定类型的模板实例，优点是没有任何
运行时消耗，但是会造成代码膨胀。  

动态派发叫做trait object，类似于java的泛型(动态绑定)或者go的interface，运用类型擦除，
编译时无法知道具体的类型，运行时根据变量具体类型查找基类虚表，找到对应类型的成员函数
地址进行调用。缺点是有运行时消耗。


