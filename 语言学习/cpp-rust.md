
<!-- vim-markdown-toc GFM -->

- [C++和Rust学习笔记](#c和rust学习笔记)
  - [1. 内存管理](#1-内存管理)
  - [2. 所有权、引用与借用机制](#2-所有权引用与借用机制)
  - [3. 生命周期](#3-生命周期)
  - [4. 数组和字符串的切片](#4-数组和字符串的切片)
  - [5. 泛型系统](#5-泛型系统)
  - [6. 常用的一些处理技巧](#6-常用的一些处理技巧)

<!-- vim-markdown-toc -->


### C++和Rust学习笔记

简单记录一些语言的特点及关键问题的处理异同


---

#### 1. 内存管理  
> 所有运行的程序都必须管理其使用计算机内存的方式。  
> 一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，
> 程序员必须亲自分配和释放内存。Rust则选择了第三种方式：通过所有权系统管理内存，编
> 译器在编译时会根据一系列的规则进行检查。  

> 堆和栈都是程序在运行时可供使用的内存，但是它们的结构不同。  
> 栈用来存储函数局部变量，函数地址等，得益于其数据结构，栈的操作速度比堆快。  
> 栈中所有数据都必须占用已知且固定的大小，堆用来存储在编译时大小未知或大小可能变化
> 的数据。

C++和C中可能有多个指针指向同一个堆中动态分配的对象，给内存管理造成很大麻烦。
即申请内存之后忘记释放造成内存泄漏、多次释放相同内存、访问已经释放了的内存产生的bug。

Rust解决了C++和C一直以来内存管理的痛点问题，C++和C中内存管理都是**变量跟着内存地址**
(指针)走，而Rust中却是**指针跟着变量走**。  
Rust中通过变量进出作用域的约定，让所有未实现 Clone 特质(Trait)、需要在堆上动态分配
内存的类型的变量通过指针信息的传递 move，实现了在任何时刻任一堆上的对象都只能有一个
变量引用它的内存地址，即任何时刻指向这个堆上对象的指针引用计数只能为1，离开变量作
用域时，Rust将自动销毁这个指针并释放内存。
关键的是，这样的功能不会造成任何运行时开销！

> 上面的这个move的特性实际上是Rust中所有权(ownership)机制的体现。  
注：Rust里面实现了Clone 特质的类型可以进行深拷贝，即复制变量数据而不是复制指针信息。
而java里的Clone接口是浅拷贝。

---


#### 2. 所有权、引用与借用机制  
- 所有权：  
  跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及
  清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。  
     - Rust 中的每一个值都有一个被称为其所有者（owner）的变量。  
     - 值有且只有`一个`所有者。  
     - 当所有者（变量）离开作用域，这个值将被丢弃。  


- 引用：   
  引用分为可变引用与不可变引用。

    1. 在任意时刻，某个变量(某块内存空间)要么只能有一个`可变`引用，要么只能有
       多个`不可变`引用。  
    2. 引用必须总是有效(生命周期概念来保证)。  

- 借用：   
  借用是专门针对`函数调用`来定义的，  
  调用函数就会进入另一个作用域，如果`传值调用`函数，那么对堆上生成的数据来说，所
  有权就会直接转移到函数之中，如果不想进行转移，可获取其引用，这一动作称借用。


- Rust中函数的三种形参类型声明方式及与C++对比：

  |      |   获取所有权   |    可变借用    |       不可变借用     |
  |:----:|:--------------:|:--------------:|:--------------------:|
  | C++  | && + std::move | & (引用或指针) | const & (引用或指针) |
  | Rust | 堆上对象传值   | &mut var       | & var                |
  | Rust | .into_iter()   | .iter_mut()    | .iter()              |


- Rust中的 **Ref** 和 **&** 究竟是什么意思总结：

  |     | 表达式中=右边 |   变量绑定时=左边  |  类型声明时  |  模式匹配中  |
  |:---:|:-------------:|:------------------:|:------------:|:------------:|
  |  &  |      借用     | 解地址操作与\*类似 | 表示引用类型 |  无效关键字  |
  | Ref |   无效关键字  |    表示引用类型    |  无效关键字  | 表示引用类型 |
  
  注：Rust中借用既可以取左值，也可以取暂态变量的右值引用。  

- **综上**： 
  **Ref**更适合称引用，**&** 称借用。引用是一个**名词**，而借用是一个**动词**。  
  借用是一种数据传递方式，与之相对的概念是拷贝和移动。
  引用是一种操作内存的数据类型，对应于指针，智能指针等。  
  Rust中引用与借用和C++中引用概念不完全相同。借用和引用是一组关系词，C++中指针
  和取地址是一组关系词。  

---


#### 3. 生命周期  
> Rust中的每一个引用都有其生命周期，也就是引用保持有效的作用域。

- 如果被引用对象比它的引用者存在时间更短，那么在编译时就会报错，也就是编译器会比
  较每一对引用和被引用对象的作用域来进行检查，注意这不是在运行期出bug！

- \`static 是指有静态生命周期的对象，其存活于整个程序期间。

- 在函数或方法定义中，生命周期的泛型语法是为了将函数的某些**形参**与其**返回值**
  的生命周期进行关联，从而避免产生悬垂指针或是违反内存安全的行为。

- 在结构体的定义中，生命周期用来指明引用字段的生命周期与结构体本身生命周期的关系。

- 生命周期的三个规则，如果不满足这三个规则，编译器就会报错：

  1. 每一个引用参数都有自己的生命周期参数。有一个引用参数的函数就有一个生命周期参数：
     有两个引用参数的函数有两个不同的生命周期参数，依此类推。  
     ```rust
     fn foo<'a>(x: &'a i32)

     fn foo<'a, 'b>(x: &'a i32, y: &'b i32)
     ```

  2. 如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：
     ```rust
     fn foo<'a>(x: &'a i32) -> &'a i32。
     ```

  3. 如果方法有多个输入生命周期参数，如果其中之一为 &self 或 &mut self，那么 self 的生
     命周期会被赋给所有输出生命周期参数。也就是结构体或者枚举本身比包含的字段生命周期长。

---


#### 4. 数组和字符串的切片  

- Rust中的切片实际是一个结构体，含有一个指向某数组**首元素**地址的指针和该数组
  片段长度的字段。  
  所以切片是一个数组部分元素的**定长**引用。  
- 而Go中切片大小是可变的，因此它的结构体多了一个代表切片capacity的字段，其他一样。  
- Rust和Go通过这样的结构避免了C和C++中直接操作指针运算可能导致的访问越界问题。
- Rust中的&str字符串切片其实和C中字符数组概念是一样的，只是Rust默认支持UTF-R编码。  
  需要注意的是Rust中一个char类型内存大小是平台无关的，占用3个bit，4个byte。
  但是字符串类型String的内存占用是变长的。String是字节可变数组Vec<u8>的封装。  

  一个字符串字节值的索引并不总是对应一个有效的Unicode标量值，跟我们眼中理解的**字母
  **更是相差甚远。比如一个英文字母可以用一个字节表示，但一个中文汉字无法用一个字节表
  示。字符串索引返回的类型是不明确的，字节值，字符还是人们眼中的字符簇？
  正是因为单个char类型和String中单个字符的内存占用大小不一样，所以String不支持直接
  索引获取单个字符的操作，只能通过String.as_byte()方法变为&str再索引。

---


#### 5. 泛型系统  
> Rust有两种实现泛型的手段，一种动态一种静态。  

静态派发类似于C++模板，在编译时单态化就能生成特定类型的模板实例，优点是没有任何运行
时消耗，但是会造成代码膨胀。  

动态派发叫做Trait Object，Trait Bound，类似于Java的泛型实现，或者Go的interface，编译
时类型擦除，无法知道具体的形参类型，运行时根据实参具体类型查找擦除的泛型基类虚表，找
到对应形参类型的成员函数地址进行调用。缺点是有运行时消耗。

> 泛型类型参数意味着代码可以适用于不同的类型。trait 和 trait bounds保证了即使类型是
> 泛型的，这些类型也会拥有所需要的功能接口。

---


#### 6. 常用的一些处理技巧

- 获取函数中局部变量，可能是栈上的也可能是堆上动态分配的(操作堆上对象比栈上慢)。

  - 栈上的：大多都是基本类型，占用空间很小，直接拷贝返回值也没什么效率损失。  
  - 堆上的：需要堆上动态分配对象的值，若是拷贝，不论是速度或是内存占用都不算最优，可以
    返回一个指向该对象的智能指针，获取其地址。或者从函数外部传递一个空指针进来，
    将该对象地址赋给指针。  
  - **注意:** 绝对不要返回一个局部引用(Rust)或者原始指针(C++)！！！
