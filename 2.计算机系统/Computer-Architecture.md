
<!-- vim-markdown-toc GFM -->

- [计算机体系结构基础](#计算机体系结构基础)
  - [内存与地址](#内存与地址)
  - [设备](#设备)
  - [汇编相关 - 硬件层面](#汇编相关---硬件层面)
  - [段页式内存管理机制](#段页式内存管理机制)
  - [现代处理器特点](#现代处理器特点)
- [什么是计算](#什么是计算)
  - [计算机怎么算](#计算机怎么算)

<!-- vim-markdown-toc -->



### 计算机体系结构基础
冯-诺伊曼体系结构：存储器、控制器、运算器、输入、输出设备。  

> 经过下面的计算机体系结构描述，应能够把一个网络客户端程序从启动加载到内存，程序调用操作系统接口发
  出网络请求，内核接收请求返回的网卡数据，把数据从内核空间复制到用户空间，然后呈现在显示外设的一系
  列过程理解清楚(当然里面还要结合
  [**网络编程**](https://github.com/Snailclimb/JavaGuide#%E7%BD%91%E7%BB%9C) 及
  [**计算机操作系统**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md)`内存管理`和`进程管理`的知识)。


#### 内存与地址
- 每个内存单元有一个地址，地址从0开始编号，CPU通过地址找到相应的内存单元，取其中的指令或读写其中的
  数据。

- 一个内存单元只能存一个字节，int，float等多**字节数据类型**保存在内存中要占用连续的多个地址，这时
  数据的内存地址是其所占内存单元的**起始地址**。


#### 设备
> 设备像内存芯片一样连接到处理器的地址总线和数据总线，还有一些设备直接集成在处理器芯片中。  
  设备中可供读写访问的单元称为设备寄存器，操作设备的过程就是初始化、读、写这些设备寄存器的过程。

- x86对于设备有独立的端口**地址空间**，访问设备寄存器和访问内存不同，这种方式称为端口(Port)IO。  
  **注意**： 这和 Socket 编程中端口不同，这里是硬件端口。TCP/IP 中 Socket 端口是软件层面的IO 接口。

- 从CPU角度看，要访问设备只有**内存映射I/O** 和**端口I/O**两种方式，都是通过**总线控制器**访问挂
  在总线上的相应设备。

- x86平台上硬盘是挂在总线上的设备，保存在硬盘上的程序不能**直接**被 CPU 取指令执行，操作系统在执行
  程序时先把它从硬盘**拷贝到内存(用户空间)**，这样CPU才能取指令执行，这一过程称为加载。  
  一个程序**并不需要**全部加载到内存才能执行(由于页面置换技术)，这使得**有限的内存**运行大程序成为可能。  
  程序加载到内存后，成为操作系统调度执行的一个任务，就是**进程**。

- 当设备需要通知CPU时(**如外部IO 数据就绪，请求读写或键盘指令时**)，通过与CPU相连的中断控制器与信
  号线引发一个**中断信号**，CPU跳转到某固定地址(CPU正在执行的指令被打断，程序计数器指向某个固定地
  址，CPU从该地址取指令)，执行**中断服务程序**(内核中的一段代码)，完成中断处理后返回先前被打断的
  地址执行后续指令。


#### 汇编相关 - 硬件层面
> 注意区分实模式，保护模式，内存分页管理功能是**保护模式**下的内存访问机制。

- CPU
  - 寄存器：有通用寄存器及特殊寄存器。
  - 程序计数器： 保存CPU取的下一条指令的地址，CPU按程序计数器保存的地址去内存中取指令然后解释执行。
  - 指令译码器： 负责解释指令含义，然后调动相应的执行单元去执行。
  - 算数逻辑单元： 运算指令的执行元件。
  - 地址和数据总线： CPU 和内存之间用地址总线、数据总线和控制线连接。

- CPU 硬件特点
  - 8086有20根地址线，可以寻址2^20/(2^10\*2^10)=1MB内存。但是内部寄存器是16位(<20bit)，无法在程序中一次访问
    整个1MB内存。所以它也是第一款支持内存分段模型的处理器。  
    下段地址和偏移地址称为逻辑地址，偏移地址叫有效地址，在指令中给出有效地址的方式叫寻址方式。  
    段的管理是由处理器的段部件负责的(物理地址 = 段地址 x 16 + 偏移地址)，它产生的地址就是物理地址。  
    **8086只有一种工作模式，即实模式**。80286(16位)也有保护模式，本页里所有16位模式都是指实模式。

  - x86-80386架构有32根地址线，可以寻址4GB内存。数据线数量是32根或者64根，每次可以读写连续的4或8个字节。  
    内部寄存器都是32位的，可以执行4GB范围内的控制转移，也可以使用32位偏移量访问任何4GB范围内的任何位置。

- 为什么会有 CPU 保护模式
  - 16位模式下，一个程序可以自由访问**不属于**它的内存位置，甚至可以对那些地方的内容进行修改。这当然是不安全，
    也不合法的，但却**没有任何机制**来限制这种行为。  

  - 在32位保护模式下，对内存的访问仍然使用段地址和偏移地址，但在每个段**能够**访问之前(如加载程序时)，必须先进
    行登记**全局描述符表GDT**(定义该程序所拥有的段)，然后才允许使用这些段。  
    定义段时，除了基地址(起始地址)外，还附加了段界限、特权级别、类型等属性。当程序访问一个段时，处理器将用**固
    件-硬件及驱动**?实施各种检查工作，以防止对内存的违规访问。  
    这样就像开公司，在实模式下，开公司不需要登记，卖什么都没人管，随时可以开张。但在保护模式下，开公司前必须先
    登记，登记的信息包括住址(段的起始地址)、经营项目(段的界限等各种访问属性)。这样，每当做的生意和登记不符时，
    就会被阻止。


#### 段页式内存管理机制
> 段的管理是由处理器的段部件负责的，每个程序或任务都有自己的段，段都用段描述符定义。

- 32位实模式下(不需注册全局描述符表GDT)  

  段地址并非真实的物理地址，物理地址 = 逻辑段地址 x 16(左移四位) + 偏移地址。

- 32位保护模式下的内存分页管理功能 - 为什么会有内存分页功能  
  - **解决段模式内存空间碎片化而导致无法分配多任务的问题。**  
    80386(32位处理器)支持多任务。在多任务环境下，任务创建需分配内存空间，当任务终止后，要回收它所占用的空间。
    在**分段模式**下，内存的分配是**不定长**的，程序大时分配大块内存，小时分配小块。时间长了会导致**内存空间
    碎片化。**  
    这种模式下会出现一种情况：**内存空间是有的，但都是小块，无法分配给某个任务。**  
    为了解决这个问题，80386引入了**分页功能**，分页是用长度固定的页来代替长度不一定的段，也就是将物理内存
    空间划分成逻辑上的页。页的**大小固定**，32位处理器一般为 4KB，通过使用页，可以**简化内存管理。**  

  - **扩充逻辑内存，在小的内存空间也能运行大的程序。**  
    操作系统虚拟内存管理利用CPU的保护模式，在处理器访问一个实际上不存在的段时，引发异常中断，执行远跳
    换页操作指令。  
    其目的是利用硬盘空间进行段的换入和换出，从而**实现**在较小的内存空间运行更大、更多的程序。  
    也可以说是让逻辑内存借助物理内存进行动态“扩充”，让程序获得更多的可用内存。

- 32位保护模式下(需注册全局描述符表GDT)  
  - 未开启分页功能时，段部件产生的地址就是**物理地址**。访问内存也需要指定一个段，但传给段部件的不是逻辑段
    地址，而是段描述符在全局描述符表中的**索引号**，段描述符中有具体的内存地址信息。  

  - 当分页功能开启时，段部件产生的地址就不再是物理地址，而是**虚拟地址**(线性地址)，虚拟地址还要经**页部件**
    映射转换，才是物理地址。  

  - 虚拟地址空间(32位-4GB)与物理地址空间(32位-4GB)是**相互独立**的。  
    物理内存都是固定大小的4KB页面。

  - 分页模式下，内存的分配涉及到虚拟内存段空间的分配和物理内存的页分配。虚拟内存与物理内存页面的映射关系用
    **页表**进行描述。

- 页表是从哪来的呢(操作系统如何与MMU配合工作)
  - 操作系统在**初始化或分配内存**时会在虚拟内存空间寻找空闲的段空间，并根据算法拆分映射到对应的物理内存页，
    然后将物理内存页地址写入页表。最后在真正加载程序时，把原本属于段的数据按页的尺寸拆开，分开写入对应的页
    面中。  
    虚拟地址(段空间)是连续的，但映射成的物理地址并不需要是连续的。

  - 有了页表后，CPU 每次执行**内存访问指令**时 MMU 都会自动去物理内存**查页表并进行地址转换**操作，地址转换
    由**硬件**自动完成，不需要用指令控制 MMU 去做。

  - 基于以上特点，每个任务都可以有自己的4GB虚拟内存空间，在整个系统中，物理页面是统一调配的。  
    代码中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址。程序被加载到内存，
    然后被CPU解释执行，地址就成了CPU执行单元发出的内存访问地址。所以在启用MMU的情况下，程序中使用的地址
    都是虚拟地址，都会引发MMU做查表和地址转换操作。

- 页面不够用怎么办
  > 每个任务都有4GB虚拟内存空间，而物理内存只有一个4GB，怎么分。

  - 操作系统虚拟内存管理利用CPU的保护模式，当处理器访问一个内存中不存在的页面时，会引发**缺页异常中断**，远跳
    执行换页操作指令。将暂时不用的页装入硬盘交换区，并从硬盘中调入马上要用的页。  
  
  - 页面置换算法 - 缓存淘汰算法类似

- CPU内存保护模式与用户态，内核态之分
  - 随着时代发展，多用户、多任务是必然，内存中会有**多个用户程序**在同时运行。为了使他们彼此隔离，防止因某
    个程序的编写错误或者崩溃而影响到操作系统和其他用户程序，使用保护模式是非常有必要的。  
    各种体系结构都有**用户态、内核态**之分，操作系统也可以在页表中设置每个内存页面的**不同访问权限**。

  - 当CPU要访问一个 VA 时，MMU **检查CPU当前处于用户态还是内核态**，访问内存的目的是读、写数据还是取指令，
    如果和 OS **先前设定**的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问并产生一个**异常**。

  - 异常由CPU内部产生，而中断由外部设备产生。异常产生就是由于CPU当前执行的指令**有问题**，如权限错误，访问
    越界。就会段错误，跳出提示框，蓝屏等。

- 用户空间和内核空间
  - 操作系统会把**虚拟地址空间**划分为**用户空间**和**内核空间**，比如x86-32位linux系统虚拟地址空间前3GB
    是用户空间，后1 GB 是内核空间。

  - 操作系统将用户程序加载到用户空间，在用户态执行，不能访问内核空间中的数据，也不能跳转到内核代码中执行。

  - CPU 在产生中断或异常时(如IO读取，段错误)，会自动**切换到内核态**，跳转到内核代码中执行异常服务程序，根
    据中断或错误类别进行相应处理。


#### 现代处理器特点
- 流水线
  为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干细小的步骤(取指、译码、寄存器分配和重命名、
  微操作排序、访存、执行、引退、写回等)，并分配给相应的单元完成。各个单元的执行是独立、并行的。这样各个步骤执行
  在时间上就会重叠起来，这种执行指令的方法就是**流水线**技术。

  > 流水线是采用分治思想把一条指令的执行过程分解成若干个细小的步骤，并由不同的单元完成，各个单元独立，并行执行。  
    要优化程序执行时间，就可以借鉴这种细化执行粒度，让每一级任务减少的思想。

  <img src="../7.Resources/parallel-PipeLine.png">


- 乱序执行
  - 为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作。  

  - 比如：`add eax, [mem]`，可以拆分成两个微操作，一个用于从内存中读取数据并保存到临时寄存器，另一个用于将eax寄存
    器和临时寄存器中的数值相加。  

  - 因为CPU存在乱序执行的行为，就使得某些操作不是原子操作，在多线程编程中产生竞争条件的问题。

  - **注意：** CPU的乱序执行和编译器的代码指令重排优化不是一回事。详情看
    **[乱序执行和指令重排](https://blog.csdn.net/lindanpeng/article/details/72459493)**。

- 高速缓存
  - 内存的存储周期都会比CPU的时钟周期慢(通俗讲即内存读取数据速度比CPU处理数据慢)，这影响了系统整体性能的提高
    (短板效应)。为了解决这个问题，现代计算机都会把存储器**分成若干级**，存储大小和速度性能成反比。CPU和内存之间
    还有高速缓存。

  - 高速缓存的用途源于程序在运行时所具有的局部性规律，跟Jit(即时编译)优化热点代码有点差不多含义。  
    多线程编程又出现了**缓存一致性**问题。
      

---


### 什么是计算
掰手指数数，需要有**数**和**运算符号**。


#### 计算机怎么算
- 人用十进制，计算机晶体管组成，只能用电压表示开关，即0和1，因此计算中采用**二进制**计算。

- 数在计算机里如何存储引出几种进制表示，进制的转换，2的补码。

- 为了程序的模块化，更易编写有了C语言，在汇编之上多了一些更符合人类习惯的抽象。  
  数据类型、运算符、函数封装、流程控制语句、

- 字符集、运算符号如何表示引出 [**字符编码**](./Encodings.md)，ASCII，UTF-8，Unicode等。


