
<!-- vim-markdown-toc GFM -->

- [排序算法](#排序算法)
  - [如何分析一个排序算法好坏](#如何分析一个排序算法好坏)
  - [平均时间复杂度为O($n^2$)的排序算法](#平均时间复杂度为on2的排序算法)
    - [冒泡](#冒泡)
    - [**插入**](#插入)
    - [选择](#选择)
  - [平均时间复杂度为O($nlogn$)的排序算法 - 分治递归](#平均时间复杂度为onlogn的排序算法---分治递归)
    - [归并](#归并)
    - [**快排**](#快排)
  - [平均时间复杂度为O($n$)的排序算法 - 线性排序](#平均时间复杂度为on的排序算法---线性排序)
    - [桶排序](#桶排序)
    - [计数排序](#计数排序)
    - [基数排序](#基数排序)
    - [堆排序－时间复杂度$O(nlogn)$](#堆排序时间复杂度onlogn)

<!-- vim-markdown-toc -->


## 排序算法

### 如何分析一个排序算法好坏
- 执行效率
  - 最好、最坏、平均时间复杂度  
    数据是否有序，对于不同的算法性能表现不同

  - 时间复杂度的系数、常数、低阶项  
    数据规模很大时可以不比较，数据规模又小的话就需要考虑。

  - 比较次数和交换(移动)次数  
    基于比较的排序算法都会进行元素的交换或移动

- 内存消耗  
  是否原地排序(空间复杂度为O(1)的算法)

- 算法稳定性  
  如果待排序的序列存在值相等的元素，经过排序后，**相等元素之间原有的先后顺序**保持不变。  
  如电商根据下单金额及时间排序。

- 有序度和逆序度：用来计算时间复杂度
  - 有序度是数组中具有有序关系的元素对的个数。
  - 倒序排列数组，比如6，5，4，3，2，1，有序度为0。
  - 完全有序的数组，有序度为 $(n-1)+(n-2)+\dots+1 = \frac{n(n - 1)}{2}$，称满有序度。
  - 逆序度＝满有序度－有序度，如果算法每执行一个操作使逆序度减1(有序度加1)，那逆序度即为算法需
    要重复执行的次数。


### 平均时间复杂度为O($n^2$)的排序算法
#### 冒泡
- 操作相邻两个数据，一次冒泡需交换数据n次，之后最大值存储在正确位置。总共需要n次冒泡。
- 稳定，原地排序算法。


#### **插入**
- 将数组分为已排序区间和未排序区间，取未排序元素，在已排序区间找到合适位置插入，初始头元素为已排序元素。
- 稳定，原地排序算法 。
- 相对冒泡排序，插入排序数据移动(1)指令比冒泡数据交换指令(3)更少。
- 优化：希尔排序


#### 选择
- 将数组分为已排序区间和未排序区间，取未排序元素中最小值，放到已排序区间末尾，初始没有已排序元素。
- 不稳定，原地排序算法。

---


> 基于分治思想的排序，采用递归编程来实现。

### 平均时间复杂度为O($nlogn$)的排序算法 - 分治递归
#### 归并
- 将数据一分为二，递归切分，直到无法再切，分别进行排序，最后将两个有序的子数组合并。
- 平均时间复杂度：$T(n)=nlog_2n+cn$
- 稳定，空间复杂度为O(n)


#### **快排**
- 在数组中任选一分区点p，遍历区间，将小于p的放左边，大于p的放右边，p在中间。再在左右两边递归
  分别进行这一操作直到所有区间缩小为1，算法结束。
- 不稳定，原地排序
- 优化：分区点选取不当时，会导致复杂度恶化为O($n^2$)


### 平均时间复杂度为O($n$)的排序算法 - 线性排序
#### 桶排序
- 理想应用场景下数据应能均匀分布在每个桶内
- 适用于处理数据量大，内存有限，无法全部加载到内存的场景。


#### 计数排序
- 桶排序的特例，用更小的桶粒度。
- 适用于数据范围区间k比要排序的数据个数n大不了多少，数据都为非负整数的情况，可直接划分成k个桶。
- O(n+k) k是数据的范围
- 非原地排序


#### 基数排序
- 每个数据位数较多，可以分割出独立的"位"来比较，而且位之间有递进的关系。比如a数据的高位
  比b数据大的话，那剩下的低位就不用比较了。然后针对每一位如果数据范围不大的话，就可以用
  线性排序。其实也是分治思想，把多位拆成每一位来比较。
- O(dn) d是维度
- 非原地排序

> glibc中qsort()排序函数在数据量小时优先用归并，以空间换时间。数据量大时用快排，当快排分
  区的区间中元素的个数小于等于4时，就用插入排序。  
  在小规模数据上，o($n^2$)时间复杂度的算法并不一定比o($nlogn$)的算法执行时间长，大O描述的
  只是算法的增长趋势，并不一定是代码实际执行时间。数据规模小时低阶、系数、常数项都会有影响。

  <img align="center" src="../20.Resources/datastructure/sort-algo.jpg" width=600 >


#### 堆排序－时间复杂度$O(nlogn)$
- 特点：不稳定，原地排序

- 实现
  - 建大顶堆，时间复杂度$O(n)$。  
    若将数组看成堆，由于堆中节点值都必须大于左右子节点，且堆为完全二叉树。所以按数组索引在堆中
    位置从上到下，从左往右最后一个有叶子节点的父节点在数组中的位置即为$\frac{n}{2}$ (注意堆中数
    据从数组下表为1的位置开始存储，代码实现简单点)。只要堆化索引为1~$\frac{n}{2}$的节点，之后的
    节点都是没有子节点的叶子节点。

  - 排序，将堆顶最大元素与数组最后一个元素交换，然后再堆化一直到结束，数组就变成有序的了。
    相当于重复n次删除堆顶元素$O(logn)$，所以整个排序时间复杂度是$O(nlogn)$。

- 实际开发为什么快排要比堆排序性能好？
  - 快排数据是顺序访问的。而堆排序的堆化步骤中数据访问是跳着的，不能有效利用CPU高速缓存。
  - 对同样的数据，由于堆在排序前先要建堆，对于本来可能有序的数据反而会使得数据的有序度下降，导致
    比快排使用的数据交换次数多。快排只有比较和交换操作，数据交换的次数不会比原本数据的逆序度高。

