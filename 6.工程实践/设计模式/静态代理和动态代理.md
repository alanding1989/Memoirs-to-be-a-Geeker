


### 什么是代理
- Proxy代理模式是一种结构型设计模式，其目的是在调用者不想或者不能够直接引用一个对象的情况下，
  为调用方提供一个代理中介以控制对某个对象的访问。  


- 代理对象就是把被代理对象包装一层，在其内部做一些额外的工作，代理类负责为委托类预处理消息
  (调用委托类前)，过滤消息并转发消息(拦截)，以及进行消息被委托类执行后的后续处理。  
  比如用户需要上facebook，而普通网络无法直接访问，网络代理帮助用户先翻墙，然后再访问facebook。

- 优点  
  代理使调用方不需要了解实现类是什么，怎么做的，而客户端只需知道代理即可(解耦合)。
  具体实现类可以使用工厂对原始对象进行封装。


### 按照代理的创建时期，代理类可以分为两种： 
> 这里以Java来说明

- 静态，编译时。  
  在程序运行前代理类的.class文件就已经存在了。由程序员创建代理类或特定工具自动生成源代码再对其编译。  
  
- 动态，运行时。  
  在程序运行时运用反射机制动态创建而成。


### 比较优缺点

#### 静态代理缺点
  - 可维护性：代理类和委托类需要实现相同接口和方法，这样就出现了大量的代码重复。如果接口增加新方法，
    那所有实现类和对应的代理类都需要实现此方法。增加了代码维护的复杂度。

  - 可扩展性：因为静态代理是编译期实现，代理只服务于一种类型的对象，如果要服务多类型的对象。势必要为
    每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了。


#### 动态代理 - 抽取代码中的可变部分
  - Java中的动态代理在运行时通过反射机制实现，实际委托对象实现需要调用的接口方法(Java中方法函数不能脱离类型存在)，
    代理对象可转型成任意需要的类型，所以能够代理**各种类型**的对象。  
    需要java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy 类的支持。
 
  - 如果把**对外接口**都通过动态代理来实现，那么所有的函数调用最终都会经过invoke函数的转发，因此我们就可以
    在调用前后做一些额外操作，把这些函数放在一个地方统一管理，减少代码的重复，降低维护的难度。  

  - 比如根据系统功能的不同可以有日志、事务、拦截器、权限控制等，这些功能都是一些通用模块，没有动态代理之前这些功能
    代码只能与业务逻辑代码写在一起，强耦合，难维护。  
    而利用动态代理可以把这些代码抽取出来，放在一起统一管理。唯一要做的就是需要定义委托类和代理类的相同接口，然后实现
    对应系统功能的 InvocationHandler 代理模板类。  
    这样实际业务调用的就是代理类，代理类增强了业务逻辑代码，感觉有点像装饰器。这也就是AOP(面向切面编程)的基本原理。

  - 在C和Cpp中，使用装饰模式，把需代理的函数作为参数传入，也可以进行统一调用。  
    感觉Java因为一切皆是对象，函数无法脱离类型而存在，所以在这上面搞了个代理抽象。


### JDK与cglib动态代理比较
- JDK动态代理只能对接口进行代理。如果委托类是普通类，Java不允许多重继承，生成的代理类的父类都是Proxy类型，没法再继承委托类。  
  Cglib可以代理普通类，原理类似于JDK动态代理，它通过字节码底层继承代理类实现，在运行期间生成的代理对象是针对目标类扩展的子类。
  类型都是Enhancer类型。  
  如果被代理类或方法被final字段修饰，那么会失效。

- JDK动态代理创建对象快，运行性能却没有Cglib创建的代理性能好。  
  所以如果是代理单例对象或者有实例池(缓存)，这种不是频繁创建代理对象的场景，更适合用Cglib。

- [cglib原理及实现](https://blog.csdn.net/gyshun/article/details/81000997)


### 总结  
  静态代理与动态代理都能实现相同的功能，而从静态代理到动态代理的这个过程，其实动态代理只是对
  类做了进一步抽象和封装，使其复用性和易用性得到进一步提升。
  AOP是一种思想，而动态代理是实现AOP思想的技术手段！

