
<!-- vim-markdown-toc GFM -->

- [计算机体系结构基础](#计算机体系结构基础)
  - [内存与地址](#内存与地址)
  - [CPU](#cpu)
  - [设备](#设备)
  - [内存管理单元MMU](#内存管理单元mmu)
- [什么是计算](#什么是计算)
  - [计算机怎么算](#计算机怎么算)

<!-- vim-markdown-toc -->



### 计算机体系结构基础
冯-诺伊曼体系结构：存储器、控制器、运算器、输入、输出设备。  

> 经过下面的计算机体系结构描述，应能够把一个网络客户端程序从启动加载到内存，程序调用操作系统接口发
  出网络请求，内核接收请求返回的网卡数据，把数据从内核空间复制到用户空间，然后呈现在显示外设的一系
  列过程理解清楚(当然里面还要结合 [**网络编程**](https://github.com/Snailclimb/JavaGuide#%E7%BD%91%E7%BB%9C) 及
  [**计算机操作系统**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md)
  `内存管理`和`进程管理`的知识)。


#### 内存与地址
- 每个内存单元有一个地址，地址从0开始编号，CPU通过地址找到相应的内存单元，取其中的指令或读写其中的
  数据。

- 一个内存单元只能存一个字节，int，float等多**字节数据类型**保存在内存中要占用连续的多个地址，这时
  数据的内存地址是其所占内存单元的**起始地址**。


#### CPU
- 寄存器
- 程序计数器： 保存CPU取的下一条指令的地址，CPU按程序计数器保存的地址去内存中取指令然后解释执行。
- 指令译码器： 负责解释指令含义，然后调动相应的执行单元去执行。
- 算数逻辑单元： 运算指令的执行元件。
- 地址和数据总线： CPU 和内存之间用地址总线、数据总线和控制线连接。


#### 设备
> 设备像内存芯片一样连接到处理器的地址总线和数据总线，还有一些设备直接集成在处理器芯片中。  
  设备中可供读写访问的单元称为设备寄存器，操作设备的过程就是初始化、读、写这些设备寄存器的过程。

- x86对于设备有独立的端口**地址空间**，访问设备寄存器和访问内存不同，这种方式称为端口(Port)IO。
  **注意**： 这和 Socket 编程中端口不同，这里是硬件端口。TCP/IP 中 Socket 端口是软件层面的IO 接口。

- 从CPU角度看，要访问设备只有**内存映射I/O** 和**端口I/O**两种方式，都是通过**总线控制器**访问挂
  在总线上的相应设备。

- x86平台上硬盘是挂在总线上的设备，保存在硬盘上的程序不能**直接**被 CPU 取指令执行，操作系统在执行
  程序时先把它从硬盘**拷贝到内存(用户空间)**，这样CPU才能取指令执行，这一过程称为加载。  
  一个程序**并不需要**全部加载到内存才能执行(由于页面置换技术)，这使得有限的内存运行大程序成为可能。  
  程序加载到内存后，成为操作系统调度执行的一个任务，就是**进程**。

- 当设备需要通知CPU时(**如外部IO 数据就绪，请求读写或键盘指令时**)，通过与CPU相连的中断控制器与信
  号线引发一个**中断信号**，CPU跳转到某固定地址(CPU正在执行的指令被打断，程序计数器指向某个固定地
  址，CPU从该地址取指令)，执行**中断服务程序**(内核中的一段代码)，完成中断处理后返回先前被打断的
  地址执行后续指令。


#### 内存管理单元MMU
> 现代处理器都有虚拟内存管理机制，需要**CPU中**的内存管理单元MMU提供支持。  
  虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

- 虚拟地址与物理地址及相互转换 - 硬件层面
  - 若无 MMU 支持，CPU 执行单元发出的内存地址直接传到CPU芯片的外部地址引脚，被内存芯片接收，称为
    **物理地址**。

  - 若有 MMU 支持，CPU 执行单元发出的内存地址将被 MMU 截获，从CPU角度到 MMU 的地址称为**虚拟地址**。
    而 MMU 将这个地址映射为另一个地址发到 CPU 芯片的外部地址引脚，也即**将 VA 映射成 PA**。  
    虚拟地址空间与物理地址空间是**相互独立**的。  

  - MMU 将 VA 映射到 PA 是以**页**为单位，32位处理器的页通常是4KB。  
    物理内存中的页称为页帧，虚拟内存的哪个页面映射到物理内存的哪个页帧是通过**页表**描述的，页表保
    存在**物理内存**中，MMU 会**查找页表**确定一个 VA 应该映射到什么 PA。  
    映射成的物理地址并不需要是连续的。

- 页表是从哪来的呢(操作系统如何与MMU配合工作)
  - 操作系统在**初始化或分配、释放内存**时会执行指令在**物理内存**中填写页表，然后用指令设置MMU，告诉
    它页表在物理内存中的什么位置。

  - 有了页表后，CPU 每次执行**内存访问指令(代码)**时MMU 都会自动去物理内存**查页表并进行地址转换**操作，
    地址转换由硬件自动完成，不需要用指令控制(代码) MMU 去做。

  - 代码中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址。程序被加载到内存，
    然后被CPU解释执行，地址就成了CPU执行单元发出的内存访问地址。所以在启用MMU的情况下，程序中使用的地址
    都是虚拟地址，都会引发MMU做查表和地址转换操作。
  
  - 内存的存储周期都会比CPU的时钟周期慢(通俗讲即内存读取数据速度比CPU处理数据慢)，这影响了系统整体性能的
    提高(短板效应)，为了解决这个问题，现代计算机都会把存储器分成若干级，存储大小和速度性能成反比。  
    CPU和内存之间还有高速缓存，多线程编程又出现了缓存一致性问题。
    
- 内存保护机制与用户态，内核态之分
  - 各种体系结构都有**用户态、内核态**之分，操作系统可以在页表中设置每个内存页面的**不同访问权限**。

  - 当CPU要访问一个 VA 时，MMU **检查CPU当前处于用户态还是内核态**，访问内存的目的是读、写数据还是取指令，
    如果和 OS **先前设定**的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问并产生一个**异常**。

  - 异常由CPU内部产生，而中断由外部设备产生。异常产生就是由于CPU当前执行的指令**有问题**，如权限错误，访问
    越界。就会段错误，跳出提示框，蓝屏等。

- 用户空间和内核空间
  - 操作系统会把**虚拟地址空间**划分为**用户空间**和**内核空间**，比如x86-32位linux系统虚拟地址空间前3 GB
    是用户空间，后1 GB 是内核空间。

  - 操作系统将用户程序加载到用户空间，在用户态执行，不能访问内核空间中的数据，也不能跳转到内核代码中执行。

  - CPU 在产生中断或异常时(如IO读取，段错误)，会自动**切换到内核态**，跳转到内核代码中执行异常服务程序，根
    据中断或错误类别进行相应处理。

---


### 什么是计算
掰手指数数，需要有**数**和**运算符号**。


#### 计算机怎么算
- 人用十进制，计算机晶体管组成，只能用电压表示开关，即0和1，因此计算中采用**二进制**计算。

- 数在计算机里如何存储引出几种进制表示，进制的转换，2的补码。

- 为了程序的模块化，更易编写有了C语言，在汇编之上多了一些更符合人类习惯的抽象。  
  数据类型、运算符、函数封装、流程控制语句、

- 字符集、运算符号如何表示引出 [**字符编码**](./Encodings.md)，ASCII，UTF-8，Unicode等。

