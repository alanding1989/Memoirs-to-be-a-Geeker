
<!-- vim-markdown-toc GFM -->

- [计算机体系结构基础](#计算机体系结构基础)
  - [内存与地址](#内存与地址)
  - [设备](#设备)
  - [汇编相关 - 硬件层面](#汇编相关---硬件层面)
  - [现代处理器特点](#现代处理器特点)
  - [内存管理单元MMU](#内存管理单元mmu)
- [什么是计算](#什么是计算)
  - [计算机怎么算](#计算机怎么算)

<!-- vim-markdown-toc -->



### 计算机体系结构基础
冯-诺伊曼体系结构：存储器、控制器、运算器、输入、输出设备。  

> 经过下面的计算机体系结构描述，应能够把一个网络客户端程序从启动加载到内存，程序调用操作系统接口发
  出网络请求，内核接收请求返回的网卡数据，把数据从内核空间复制到用户空间，然后呈现在显示外设的一系
  列过程理解清楚(当然里面还要结合
  [**网络编程**](https://github.com/Snailclimb/JavaGuide#%E7%BD%91%E7%BB%9C) 及
  [**计算机操作系统**](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md)`内存管理`和`进程管理`的知识)。


#### 内存与地址
- 每个内存单元有一个地址，地址从0开始编号，CPU通过地址找到相应的内存单元，取其中的指令或读写其中的
  数据。

- 一个内存单元只能存一个字节，int，float等多**字节数据类型**保存在内存中要占用连续的多个地址，这时
  数据的内存地址是其所占内存单元的**起始地址**。


#### 设备
> 设备像内存芯片一样连接到处理器的地址总线和数据总线，还有一些设备直接集成在处理器芯片中。  
  设备中可供读写访问的单元称为设备寄存器，操作设备的过程就是初始化、读、写这些设备寄存器的过程。

- x86对于设备有独立的端口**地址空间**，访问设备寄存器和访问内存不同，这种方式称为端口(Port)IO。
  **注意**： 这和 Socket 编程中端口不同，这里是硬件端口。TCP/IP 中 Socket 端口是软件层面的IO 接口。

- 从CPU角度看，要访问设备只有**内存映射I/O** 和**端口I/O**两种方式，都是通过**总线控制器**访问挂
  在总线上的相应设备。

- x86平台上硬盘是挂在总线上的设备，保存在硬盘上的程序不能**直接**被 CPU 取指令执行，操作系统在执行
  程序时先把它从硬盘**拷贝到内存(用户空间)**，这样CPU才能取指令执行，这一过程称为加载。  
  一个程序**并不需要**全部加载到内存才能执行(由于页面置换技术)，这使得**有限的内存**运行大程序成为可能。  
  程序加载到内存后，成为操作系统调度执行的一个任务，就是**进程**。

- 当设备需要通知CPU时(**如外部IO 数据就绪，请求读写或键盘指令时**)，通过与CPU相连的中断控制器与信
  号线引发一个**中断信号**，CPU跳转到某固定地址(CPU正在执行的指令被打断，程序计数器指向某个固定地
  址，CPU从该地址取指令)，执行**中断服务程序**(内核中的一段代码)，完成中断处理后返回先前被打断的
  地址执行后续指令。


#### 汇编相关 - 硬件层面
- CPU
  - 寄存器：有通用寄存器及特殊寄存器。
  - 程序计数器： 保存CPU取的下一条指令的地址，CPU按程序计数器保存的地址去内存中取指令然后解释执行。
  - 指令译码器： 负责解释指令含义，然后调动相应的执行单元去执行。
  - 算数逻辑单元： 运算指令的执行元件。
  - 地址和数据总线： CPU 和内存之间用地址总线、数据总线和控制线连接。

- 8086有20根地址线，可以寻址2^20/(2^10\*2^10)=1MB内存。但是内部寄存器是16位(<20bit)，无法在程序中一次访问
  整个1MB内存。所以它也是第一款支持内存分段模型的处理器。  
  段地址和偏移地址称为逻辑地址，偏移地址叫有效地址，在指令中给出有效地址的方式叫寻址方式。  
  段的管理是由处理器的段部件负责的(物理地址 = 段地址 x 16 + 偏移地址)，它产生的地址就是物理地址。  
  8086只有一种工作模式，即实模式。

- x86-80386架构有32根地址线，可以寻址4GB内存。数据线数量是32根或者64根，每次可以读写连续的４或８个字节。  
  内部寄存器都是32位的，可以执行4GB范围内的控制转移，也可以使用32位偏移量访问任何我4GB范围内的任何位置。

- 16位模式下，一个程序可以自由访问**不属于**它的内存位置，甚至可以对那些地方的内容进行修改。这当然是不安全，
  也不合法的，但却**没有任何机制**来限制这种行为。在32位模式下，处理器要求在加载程序时，先定义该程序所拥有
  的段，然后才允许使用这些段。定义段时，除了基地址(起始地址)外，还附加了段界限、特权级别、类型等属性。当
  程序访问一个段时，处理器将用**固件-硬件及驱动**?实施各种检查工作，以防止对内存的违规访问。

- 80386-32位处理器支持多任务。在多任务环境下，任务创建需分配内存空间，当任务终止后，要回收它所占用的空间。
  在分段模式下，内存的分配是不定长的，程序大时分配大块内存，小时分配小块。时间长了会导致**内存空间碎片化。**  
  这种模式下会出现一种情况：**内存空间是有的，但都是小块，无法分配给某个任务。**  
  为了解决这个问题，32位处理器支持分页功能，分页功能将物理内存空间划分成逻辑上的页。页的大小固定，32位处理
  器一般为4KB，通过使用页，可以**简化内存管理。**  

- 当页功能开启时，段部件产生的地址就不再是物理地址，而是线性地址，线性地址还要经**页部件**转换，才是物理地址。  
  未开启页功能时，线性地址就是物理地址。


#### 现代处理器特点
- 流水线
  为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解成若干细小的步骤(取指、译码、寄存器分配和重命名、
  微操作排序、访存、执行、引退、写回等)，并分配给相应的单元完成。各个单元的执行是独立、并行的。这样各个步骤执行
  在时间上就会重叠起来，这种执行指令的方法就是**流水线**技术。

  > 流水线是采用分治思想把一条指令的执行过程分解成若干个细小的步骤，并由不同的单元完成，各个单元独立，并行执行。  
    要优化程序执行时间，就可以借鉴这种细化执行粒度，让每一级任务减少的思想。

  <img src="../resources/parallel-PipeLine.png">


- 乱序执行
  - 为了实现流水线技术，需要将指令拆分成更小的可独立执行部分，即拆分成微操作。  

  - 比如：`add eax, [mem]`，可以拆分成两个微操作，一个用于从内存中读取数据并保存到临时寄存器，另一个用于将eax寄存
    器和临时寄存器中的数值相加。  

  - 因为CPU存在乱序执行的行为，就使得某些操作不是原子操作，在多线程编程中产生竞争条件的问题。

  - **注意：** CPU的乱序执行和编译器的代码指令重排优化不是一回事。详情看
    **[乱序执行和指令重排](https://blog.csdn.net/lindanpeng/article/details/72459493)**。

- 高速缓存
  - 内存的存储周期都会比CPU的时钟周期慢(通俗讲即内存读取数据速度比CPU处理数据慢)，这影响了系统整体性能的提高
    (短板效应)。为了解决这个问题，现代计算机都会把存储器**分成若干级**，存储大小和速度性能成反比。CPU和内存之间
    还有高速缓存。

  - 高速缓存的用途源于程序在运行时所具有的局部性规律，跟Jit(即时编译)优化热点代码有点差不多含义。  
    多线程编程又出现了**缓存一致性**问题。
      

#### 内存管理单元MMU
> 现代处理器都有虚拟内存管理机制，需要**CPU中**的内存管理单元MMU提供支持。  
  虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

- 虚拟地址与物理地址及相互转换
  - 若无 MMU 支持，CPU 执行单元发出的内存地址直接传到CPU芯片的外部地址引脚，被内存芯片接收，称为
    **物理地址**。

  - 若有 MMU 支持，CPU 执行单元发出的内存地址将被 MMU 截获，从CPU到 MMU 的地址称为**虚拟地址(线性地址)**。
    而 MMU 将这个地址映射为另一个地址发到 CPU 芯片的外部地址引脚，也即**将 VA 映射成 PA**。  
    虚拟地址空间与物理地址空间是**相互独立**的。  

  - MMU 将 VA 映射到 PA 是以**页**为单位，32位处理器(内存大小为2^32bit)的页通常是4KB(占用内存2^12bit)。  
    物理内存中的页称为页帧，虚拟内存的哪个页面映射到物理内存的哪个页帧是通过**页表**描述的，页表保
    存在**物理内存**中，MMU 会**查找页表**确定一个 VA 应该映射到什么 PA。  
    映射成的物理地址并不需要是连续的。

- 页表是从哪来的呢(操作系统如何与MMU配合工作)
  - 操作系统在**初始化或分配、释放内存**时会执行指令在**物理内存**中填写页表，然后用指令设置MMU，告诉
    它页表在物理内存中的什么位置。

  - 有了页表后，CPU 每次执行**内存访问指令(代码)**时MMU 都会自动去物理内存**查页表并进行地址转换**操作，
    地址转换由硬件自动完成，不需要用指令控制(代码) MMU 去做。

  - 代码中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址。程序被加载到内存，
    然后被CPU解释执行，地址就成了CPU执行单元发出的内存访问地址。所以在启用MMU的情况下，程序中使用的地址
    都是虚拟地址，都会引发MMU做查表和地址转换操作。
  
- 内存保护机制与用户态，内核态之分
  - 随着时代发展，多用户、多任务是必然，内存中会有多个用户程序在同时运行。为了使他们彼此隔离，防止因某个程序
    的编写错误或者崩溃而影响到操作系统和其他用户程序，使用保护模式是非常有必要的。  
    各种体系结构都有**用户态、内核态**之分，操作系统可以在页表中设置每个内存页面的**不同访问权限**。

  - 当CPU要访问一个 VA 时，MMU **检查CPU当前处于用户态还是内核态**，访问内存的目的是读、写数据还是取指令，
    如果和 OS **先前设定**的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问并产生一个**异常**。

  - 异常由CPU内部产生，而中断由外部设备产生。异常产生就是由于CPU当前执行的指令**有问题**，如权限错误，访问
    越界。就会段错误，跳出提示框，蓝屏等。

- 用户空间和内核空间
  - 操作系统会把**虚拟地址空间**划分为**用户空间**和**内核空间**，比如x86-32位linux系统虚拟地址空间前3 GB
    是用户空间，后1 GB 是内核空间。

  - 操作系统将用户程序加载到用户空间，在用户态执行，不能访问内核空间中的数据，也不能跳转到内核代码中执行。

  - CPU 在产生中断或异常时(如IO读取，段错误)，会自动**切换到内核态**，跳转到内核代码中执行异常服务程序，根
    据中断或错误类别进行相应处理。


---


### 什么是计算
掰手指数数，需要有**数**和**运算符号**。


#### 计算机怎么算
- 人用十进制，计算机晶体管组成，只能用电压表示开关，即0和1，因此计算中采用**二进制**计算。

- 数在计算机里如何存储引出几种进制表示，进制的转换，2的补码。

- 为了程序的模块化，更易编写有了C语言，在汇编之上多了一些更符合人类习惯的抽象。  
  数据类型、运算符、函数封装、流程控制语句、

- 字符集、运算符号如何表示引出 [**字符编码**](./Encodings.md)，ASCII，UTF-8，Unicode等。


