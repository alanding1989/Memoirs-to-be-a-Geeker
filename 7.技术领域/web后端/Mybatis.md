
<!-- vim-markdown-toc GFM -->

- [MyBatis 是什么](#mybatis-是什么)
- [缓存](#缓存)
  - [一二级缓存基本概念](#一二级缓存基本概念)
  - [集成Redis缓存框架](#集成redis缓存框架)
  - [二级缓存的脏数据](#二级缓存的脏数据)
  - [二级缓存适用场景](#二级缓存适用场景)

<!-- vim-markdown-toc -->



### MyBatis 是什么

MyBatis 是一款优秀的持久层框架，支持定制化 SQL语句、存储过程以及高级映射。它避免了几乎所有的 JDBC 代码和
手动设置参数以及获取结果集。  
例如数据库的驱动包，连接、连接池，可以通过配置文件的方式直接进行配置连接。通过框架去管理这些东西，简化开发流程。


### 缓存

#### 一二级缓存基本概念
- 一级缓存默认启用，二级需要开启。

- 为什么有了一级缓存还要有二级缓存。

- Mybatis的一级缓存在每个单独sqlSession中，只要通过session查询的数据，都会放在session里，
  下一次再查询相同id的数据，都直接从缓存中取，而不会命中数据库。  
  可以配置flushCache＝"true"使查询数据前清空当前的一级缓存，因此每次都会从数据库查询数据。
  但会影响同一session中所有缓存的查询。  
  
- Mybatis二级缓存存在于sqlSessionFactory的生命周期中(Spring中就是Mapper，同一个命名空间内)，
  如果两次查询基于同一个SessionFactory，那么就从二级缓存中取数据，而不用到数据库里去取了。  
  - 二级缓存默认为启用状态，是序列化缓存，还有许多其他效果。与对应Mapper映射类绑定。  

  - 默认二级缓存为可读写缓存，mapper对应类需实现Serializable接口，会通过序列化和反序列化来保证
    返回缓存对象的拷贝。
    如果配置为只读缓存，Mabatis会使用Map存储缓存值，这时从缓存中获取的对象就是同一个实例。
    

#### 集成Redis缓存框架
Mybatis默认提供的缓存是基于Map实现的内存缓存，可满足基本应用。但当要缓存大量数据时，内存资源会紧张。

利用Redis将分布式应用连接到同一个缓存服务器，实现分布式应用间的缓存共享。如果使用Mybatis自带缓存或
基础的EhCache缓存，分布式应用会拥有自己的缓存，他们之间不会共享，这种方式会消耗更多的服务器资源。


#### 二级缓存的脏数据
- 产生原因:
  二级缓存是和命名空间绑定的，每一个Mapper映射文件都拥有自己的二级缓存，不同Mapper的二级缓存互不影响。
  在多表联查的场景中，增删改查不在一个映射文件中，查询的缓存未必都被清空，就会造成数据不同步，即脏数据。

- 解决
  利用参照缓存配置，当某几个可以作为一个业务整体时，让几个会关联的表同时使用一个二级缓存。  
  但并不是所有的关联查询都可以这么解决，当表复杂时没有意义。


#### 二级缓存适用场景
> 二级缓存主要会发生在多表联查的场景中，所以非这样的场景就可用。

- 以查询为主的应用，只有少量增删改查。

- 多数以单表操作存在，很少存在关联表。

- 可按业务划分对表进行分组，如关联表比较少，可通过参照缓存进行配置。

